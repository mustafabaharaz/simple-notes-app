<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Notes - Complete Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            color: #333;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }
        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
        }
        .sidebar-header h1 {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }
        .search-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            margin-bottom: 10px;
        }
        .header-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }
        .header-buttons button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            text-align: center;
        }
        .header-buttons button:hover {
            background: #f0f0f0;
        }
        .header-buttons button.active {
            background: #007AFF;
            color: white;
            border-color: #007AFF;
        }
        .bulk-actions, .bulk-trash-actions {
            display: none;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        #bulk-actions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
        }
        #bulk-trash-actions {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        .bulk-actions.active, .bulk-trash-actions.active {
            display: block;
        }
        .bulk-action-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        .bulk-action-buttons button {
            padding: 5px 10px;
            font-size: 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }
        .bulk-action-buttons button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .sidebar-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .section-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }
        .section-tab {
            flex: 1;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 13px;
            transition: all 0.2s;
        }
        .section-tab.active {
            background: white;
            font-weight: 500;
        }
        .section-tab .count {
            background: #666;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            margin-left: 5px;
        }
        .section-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }
        .notes-list, .projects-list {
            display: none;
            padding: 10px;
        }
        .notes-list.active, .projects-list.active {
            display: block;
        }
        .sort-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .sort-controls select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        .sort-controls button {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .sort-controls button:hover {
            background: #f0f0f0;
        }
        .sort-controls button.active {
            background: #007AFF;
            color: white;
            border-color: #007AFF;
        }
        .trash-section-bottom .trash-list {
            display: block;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .sidebar-spacer {
            flex: 1;
        }
        .trash-section-bottom {
            border-top: 1px solid #e0e0e0;
            background: #f8f9fa;
            padding: 15px;
        }
        .trash-section-bottom h3 {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 10px;
            color: #666;
        }
        .note-item, .trash-item, .project-item {
            padding: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            background: white;
            transition: all 0.2s;
            position: relative;
        }
        .note-item:hover, .trash-item:hover, .project-item:hover {
            border-color: #007AFF;
            box-shadow: 0 2px 8px rgba(0,122,255,0.1);
        }
        .note-item.active {
            border-color: #007AFF;
            box-shadow: 0 2px 8px rgba(0,122,255,0.2);
            background: #f0f8ff;
        }
        .project-item.active {
            border-color: #28a745;
            background: #f0fff0;
        }
        .selection-mode .note-item,
        .selection-mode .trash-item {
            padding-left: 40px;
            cursor: pointer;
        }
        .selection-mode .note-item:hover,
        .selection-mode .trash-item:hover {
            background: #f0f8ff;
        }
        .selection-checkbox {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }
        .note-item.selected, .trash-item.selected {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        .note-title {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 4px;
            color: #333;
        }
        .note-subtitle {
            font-size: 12px;
            color: #666;
        }
        .project-name {
            font-weight: 500;
            font-size: 14px;
        }
        .project-note-count {
            float: right;
            background: #f0f0f0;
            color: #666;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
        }
        .importance-dot {
            position: absolute;
            right: 12px;
            top: 12px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }
        .importance-dot.low { background: #28a745; }
        .importance-dot.medium { background: #ffc107; }
        .importance-dot.high { background: #dc3545; }
        .reminder-indicator {
            font-size: 11px;
            color: #007AFF;
            margin-top: 4px;
        }
        .reminder-indicator.reminder-overdue {
            color: #dc3545;
            font-weight: bold;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: white;
        }
        .editor-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #fafafa;
            position: relative;
        }
        .note-title-field {
            width: 100%;
            padding: 12px 0;
            border: none;
            font-size: 24px;
            font-weight: 600;
            background: transparent;
            outline: none;
            color: #333;
        }
        .note-title-field::placeholder {
            color: #999;
        }
        .auto-save-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 12px;
            color: #666;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .auto-save-indicator.saving {
            opacity: 1;
            color: #007AFF;
        }
        .auto-save-indicator.saved {
            opacity: 1;
            color: #28a745;
        }
        .auto-save-indicator.error {
            opacity: 1;
            color: #dc3545;
        }
        .editor-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            border-bottom: 1px solid #e0e0e0;
            background: white;
            flex-wrap: wrap;
        }
        .editor-toolbar.hidden {
            display: none;
        }
        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid #e0e0e0;
        }
        .toolbar-group:last-child {
            border-right: none;
        }
        .toolbar-btn {
            padding: 6px 10px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .toolbar-btn:hover {
            background: #f0f0f0;
        }
        .toolbar-btn.active {
            background: #007AFF;
            color: white;
            border-color: #007AFF;
        }
        .toolbar-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .priority-btn.active.priority-low {
            background: #28a745;
            border-color: #28a745;
        }
        .priority-btn.active.priority-medium {
            background: #ffc107;
            border-color: #ffc107;
            color: #333;
        }
        .priority-btn.active.priority-high {
            background: #dc3545;
            border-color: #dc3545;
        }
        .font-size-select, .project-select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        .reminder-date {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
            display: none;
            opacity: 0;
            transform: translateX(-10px);
            transition: all 0.3s ease;
        }
        .reminder-date.reminder-date-visible {
            opacity: 1;
            transform: translateX(0);
        }
        .reminder-date.reminder-date-hidden {
            opacity: 0;
            transform: translateX(-10px);
        }
        .history-status {
            font-size: 11px;
            color: #666;
            margin-left: 10px;
        }
        .note-editor {
            flex: 1;
            padding: 30px;
            border: none;
            outline: none;
            font-size: 16px;
            line-height: 1.6;
            font-family: inherit;
            overflow-y: auto;
            background: white;
        }
        .note-editor[data-placeholder]:empty::before {
            content: attr(data-placeholder);
            color: #999;
            font-style: italic;
        }
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
            padding: 5px 0;
            min-width: 160px;
        }
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }
        .context-menu-item:hover {
            background: #f0f0f0;
        }
        .context-menu-item.disabled {
            color: #999;
            cursor: not-allowed;
        }
        .context-menu-item.disabled:hover {
            background: transparent;
        }
        .priority-row {
            display: flex;
            padding: 5px;
        }
        .priority-row .context-menu-item {
            flex: 1;
            text-align: center;
            padding: 5px;
            margin: 0 2px;
            border-radius: 3px;
        }
        .empty-trash-btn {
            margin: 10px;
            padding: 8px 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
        }
        .empty-trash-btn:hover {
            background: #c82333;
        }
        
        /* Save feedback notification */
        .save-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            z-index: 1000;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .save-notification.show {
            opacity: 1;
            transform: translateX(0);
        }
        .save-notification.error {
            background: #dc3545;
        }
        .save-notification.warning {
            background: #ffc107;
            color: #333;
        }
        
        /* Keyboard shortcuts help */
        .keyboard-shortcuts-help {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 300px;
        }
        .keyboard-shortcuts-help.show {
            opacity: 1;
            transform: translateY(0);
        }
        .keyboard-shortcuts-help h4 {
            margin-bottom: 8px;
            font-size: 13px;
            color: #007AFF;
        }
        .keyboard-shortcuts-help ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .keyboard-shortcuts-help li {
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
        }
        .keyboard-shortcuts-help .key {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 11px;
        }
        
        /* Export/Import modal styling */
        .export-modal, .import-modal, .templates-modal, .encryption-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .export-modal.show, .import-modal.show, .templates-modal.show, .encryption-modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            min-width: 400px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease;
        }
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        .modal-header h2 {
            font-size: 24px;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }
        .export-options, .import-options, .templates-grid, .encryption-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .export-option, .import-option, .template-card, .encryption-option {
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }
        .export-option:hover, .import-option:hover, .template-card:hover, .encryption-option:hover {
            border-color: #007AFF;
            background: #f0f8ff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,122,255,0.15);
        }
        .encryption-option.selected {
            border-color: #007AFF;
            background: #f0f8ff;
        }
        .export-option .icon, .import-option .icon, .template-card .template-icon, .encryption-option .icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }
        .export-option .title, .import-option .title, .template-card .template-title, .encryption-option .title {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
            color: #333;
        }
        .export-option .description, .import-option .description, .template-card .template-description, .encryption-option .description {
            font-size: 13px;
            color: #666;
            line-height: 1.4;
        }
        .template-card .template-preview {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #666;
            max-height: 100px;
            overflow-y: auto;
            text-align: left;
            margin-top: 10px;
        }
        .export-scope {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .export-scope h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #333;
        }
        .export-scope label {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        .export-scope input[type="radio"] {
            margin-right: 8px;
        }
        .import-file-input {
            margin-bottom: 20px;
        }
        .import-file-input input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 8px;
            background: #fafafa;
            cursor: pointer;
        }
        .import-preview {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: monospace;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }
        .password-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            margin: 10px 0;
        }
        .password-input:focus {
            outline: none;
            border-color: #007AFF;
        }
        .password-strength {
            height: 4px;
            background: #f0f0f0;
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }
        .password-strength-bar {
            height: 100%;
            transition: all 0.3s;
            border-radius: 2px;
        }
        .password-strength.weak .password-strength-bar {
            width: 25%;
            background: #dc3545;
        }
        .password-strength.medium .password-strength-bar {
            width: 50%;
            background: #ffc107;
        }
        .password-strength.strong .password-strength-bar {
            width: 75%;
            background: #28a745;
        }
        .password-strength.very-strong .password-strength-bar {
            width: 100%;
            background: #007AFF;
        }
        .encryption-status {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 13px;
            color: #1976d2;
        }
        
        /* Phase 3: Drag and Drop Styling */
        .note-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .note-item.drag-over {
            border-color: #007AFF;
            background: #f0f8ff;
            transform: translateY(-2px);
        }
        .drag-handle {
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            color: #ccc;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .note-item:hover .drag-handle {
            opacity: 1;
        }
        .drag-handle:hover {
            color: #007AFF;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .custom-order-mode .note-item {
            padding-left: 30px;
        }
        .custom-order-mode .drag-handle {
            opacity: 1;
        }
        .encrypted-note-indicator {
            position: absolute;
            top: 8px;
            right: 32px;
            color: #007AFF;
            font-size: 14px;
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            .sidebar {
                width: 100%;
                height: 40vh;
            }
            .main-content {
                height: 60vh;
            }
            .editor-toolbar {
                padding: 10px;
                gap: 5px;
            }
            .toolbar-group {
                padding: 0 5px;
            }
            .header-buttons {
                grid-template-columns: 1fr;
                gap: 4px;
            }
            .modal-content {
                margin: 10px;
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <h1>📝 Simple Notes</h1>
            <input type="text" id="search-notes" class="search-input" placeholder="Search notes...">
            <div class="header-buttons">
                <button id="new-note">📝 New Note</button>
                <button id="templates-btn">📋 Templates</button>
                <button id="select-mode">☑️ Select</button>
                <button id="new-project">📁 New Project</button>
                <button id="show-all-notes">📄 All Notes</button>
                <button id="export-btn">📤 Export</button>
                <button id="import-btn">📥 Import</button>
                <button id="encryption-btn">🔐 Security</button>
            </div>

            <div id="bulk-actions" class="bulk-actions">
                <div class="bulk-action-buttons">
                    <button id="delete-selected">🗑️ Delete Selected</button>
                    <button id="cancel-selection">Cancel</button>
                </div>
            </div>

            <div id="bulk-trash-actions" class="bulk-trash-actions">
                <div class="bulk-action-buttons">
                    <button id="restore-selected">↩️ Restore Selected</button>
                    <button id="delete-selected-permanently">🗑️ Delete Forever</button>
                    <button id="cancel-trash-selection">Cancel</button>
                </div>
            </div>
        </div>
        <div class="sidebar-section">
            <div class="section-tabs">
                <button class="section-tab active" data-section="notes">
                    Notes <span id="notes-count" class="count">0</span>
                </button>
                <button class="section-tab" data-section="projects">
                    Projects <span id="projects-count" class="count">0</span>
                </button>
            </div>

            <div class="section-content">
                <div id="notes-list" class="notes-list active">
                    <div class="sort-controls">
                        <span>Sort:</span>
                        <select id="sort-select">
                            <option value="updated">Last Updated</option>
                            <option value="created">Created Date</option>
                            <option value="title">Title A-Z</option>
                            <option value="importance">Priority</option>
                            <option value="custom">Custom Order</option>
                        </select>
                        <button id="toggle-custom-order" class="sort-controls-btn">📌 Custom Order</button>
                    </div>
                    <div id="notes-container"></div>
                </div>
                <div id="projects-list" class="projects-list"></div>
            </div>
        </div>
        <div class="sidebar-spacer"></div>
        <div class="trash-section-bottom">
            <h3>🗑️ Trash <span id="trash-count" class="count">0</span></h3>
            <div id="trash-list" class="trash-list active">
                <button id="empty-trash" class="empty-trash-btn">Empty Trash</button>
            </div>
        </div>
    </div>
    <div class="main-content">
        <div class="editor-header">
            <input type="text" id="note-title-field" placeholder="Note title..." />
            <div class="auto-save-indicator" id="auto-save-indicator">Auto-saved</div>
        </div>
        <div id="editor-toolbar" class="editor-toolbar">
            <div class="toolbar-group">
                <button id="toggle-formatting" class="toolbar-btn active">📝 Formatting</button>
            </div>

            <div class="toolbar-group">
                <button id="undo-btn" class="toolbar-btn" disabled>↶ Undo</button>
                <button id="redo-btn" class="toolbar-btn" disabled>↷ Redo</button>
                <span id="history-status" class="history-status">No history</span>
            </div>

            <div class="toolbar-group">
                <button id="bold-btn" class="toolbar-btn">B</button>
                <button id="italic-btn" class="toolbar-btn">I</button>
                <button id="underline-btn" class="toolbar-btn">U</button>
            </div>

            <div class="toolbar-group">
                <select id="font-size-select" class="font-size-select">
                    <option value="12px">12px</option>
                    <option value="14px">14px</option>
                    <option value="16px" selected>16px</option>
                    <option value="18px">18px</option>
                    <option value="20px">20px</option>
                    <option value="24px">24px</option>
                </select>
            </div>

            <div class="toolbar-group">
                <button id="align-left-btn" class="toolbar-btn">⬅️</button>
                <button id="align-center-btn" class="toolbar-btn">↔️</button>
                <button id="align-right-btn" class="toolbar-btn">➡️</button>
            </div>

            <div class="toolbar-group">
                <button id="bullet-btn" class="toolbar-btn">• List</button>
                <button id="date-btn" class="toolbar-btn">📅 Date</button>
            </div>

            <div class="toolbar-group">
                <button id="priority-normal" class="toolbar-btn priority-btn active">Normal</button>
                <button id="priority-low" class="toolbar-btn priority-btn priority-low">Low</button>
                <button id="priority-medium" class="toolbar-btn priority-btn priority-medium">Medium</button>
                <button id="priority-high" class="toolbar-btn priority-btn priority-high">High</button>
            </div>

            <div class="toolbar-group">
                <select id="project-select" class="project-select">
                    <option value="">No Project</option>
                </select>
            </div>

            <div class="toolbar-group">
                <button id="remind-me-btn" class="toolbar-btn">🔔 Remind Me</button>
                <input type="date" id="reminder-date" class="reminder-date" />
            </div>

            <div class="toolbar-group">
                <button id="clear-btn" class="toolbar-btn">🧹 Clear Format</button>
            </div>
        </div>
        <div id="note-editor" class="note-editor" contenteditable="true" data-placeholder="Create a new note to get started..."></div>
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="context-menu">
        <div id="ctx-date" class="context-menu-item">📅 Insert Date</div>
        <div id="ctx-remind" class="context-menu-item">🔔 Set Reminder</div>
        <div id="ctx-delete-note" class="context-menu-item">🗑️ Delete Note</div>

        <div id="priority-row" class="priority-row">
            <div id="ctx-priority-none" class="context-menu-item">None</div>
            <div id="ctx-priority-low" class="context-menu-item">Low</div>
            <div id="ctx-priority-medium" class="context-menu-item">Med</div>
            <div id="ctx-priority-high" class="context-menu-item">High</div>
        </div>

        <div id="ctx-restore-note" class="context-menu-item">↩️ Restore Note</div>
        <div id="ctx-delete-permanently" class="context-menu-item">🗑️ Delete Forever</div>
        <div id="ctx-rename-project" class="context-menu-item">✏️ Rename Project</div>
        <div id="ctx-delete-project" class="context-menu-item">🗑️ Delete Project</div>
    </div>

    <!-- Notifications -->
    <div id="save-notification" class="save-notification"></div>
    
    <!-- Keyboard Shortcuts Help -->
    <div id="keyboard-shortcuts-help" class="keyboard-shortcuts-help">
        <h4>⌨️ Keyboard Shortcuts</h4>
        <ul>
            <li><span>New Note</span><span class="key">Ctrl+N</span></li>
            <li><span>Templates</span><span class="key">Ctrl+T</span></li>
            <li><span>Save Note</span><span class="key">Ctrl+S</span></li>
            <li><span>Undo</span><span class="key">Ctrl+Z</span></li>
            <li><span>Redo</span><span class="key">Ctrl+Y</span></li>
            <li><span>Export</span><span class="key">Ctrl+E</span></li>
            <li><span>Security</span><span class="key">Ctrl+K</span></li>
            <li><span>Delete Selected</span><span class="key">Delete</span></li>
            <li><span>Search</span><span class="key">Ctrl+F</span></li>
            <li><span>Toggle Help</span><span class="key">Ctrl+?</span></li>
        </ul>
    </div>

    <!-- Export Modal -->
    <div id="export-modal" class="export-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📤 Export Notes</h2>
                <button id="export-modal-close" class="modal-close">&times;</button>
            </div>
            
            <div class="export-scope">
                <h3>Export Scope</h3>
                <label>
                    <input type="radio" name="export-scope" value="all" checked>
                    Export all notes and projects
                </label>
                <label>
                    <input type="radio" name="export-scope" value="current-project">
                    Export current project only
                </label>
                <label>
                    <input type="radio" name="export-scope" value="current-note">
                    Export current note only
                </label>
            </div>
            
            <div class="export-options">
                <div class="export-option" data-format="json">
                    <span class="icon">📋</span>
                    <div class="title">JSON Format</div>
                    <div class="description">Complete backup with all metadata, formatting, and structure</div>
                </div>
                
                <div class="export-option" data-format="markdown">
                    <span class="icon">📝</span>
                    <div class="title">Markdown</div>
                    <div class="description">Human-readable format compatible with most text editors</div>
                </div>
                
                <div class="export-option" data-format="txt">
                    <span class="icon">📄</span>
                    <div class="title">Plain Text</div>
                    <div class="description">Simple text format without formatting or metadata</div>
                </div>
                
                <div class="export-option" data-format="html">
                    <span class="icon">🌐</span>
                    <div class="title">HTML</div>
                    <div class="description">Web format preserving all formatting and styles</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="import-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📥 Import Notes</h2>
                <button id="import-modal-close" class="modal-close">&times;</button>
            </div>
            
            <div class="import-file-input">
                <input type="file" id="import-file" accept=".json,.txt,.md,.html" multiple>
                <p style="margin-top: 10px; font-size: 13px; color: #666;">
                    Select JSON, Markdown, Text, or HTML files to import
                </p>
            </div>
            
            <div id="import-preview" class="import-preview" style="display: none;">
                <h4>Import Preview:</h4>
                <div id="import-preview-content"></div>
            </div>
            
            <div class="import-options">
                <div class="import-option" id="import-merge">
                    <span class="icon">🔄</span>
                    <div class="title">Merge with Existing</div>
                    <div class="description">Add imported notes to your current collection</div>
                </div>
                
                <div class="import-option" id="import-replace">
                    <span class="icon">⚠️</span>
                    <div class="title">Replace All Data</div>
                    <div class="description">Replace all current notes with imported data</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Templates Modal -->
    <div id="templates-modal" class="templates-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📋 Note Templates</h2>
                <button id="templates-modal-close" class="modal-close">&times;</button>
            </div>
            
            <div class="templates-grid">
                <div class="template-card" data-template="meeting">
                    <span class="template-icon">🤝</span>
                    <div class="template-title">Meeting Notes</div>
                    <div class="template-description">Structured format for meeting minutes and action items</div>
                    <div class="template-preview"># Meeting: [Title]
📅 Date: [Date]
👥 Attendees: 
📋 Agenda:
- 
💡 Key Points:
- 
✅ Action Items:
- [ ] </div>
                </div>
                
                <div class="template-card" data-template="todo">
                    <span class="template-icon">✅</span>
                    <div class="template-title">To-Do List</div>
                    <div class="template-description">Checklist format for tasks and project planning</div>
                    <div class="template-preview"># To-Do: [Project Name]
📅 Due: [Date]
🎯 Priority: [High/Medium/Low]

## Tasks:
- [ ] Task 1
- [ ] Task 2
- [ ] Task 3

## Notes:
</div>
                </div>
                
                <div class="template-card" data-template="journal">
                    <span class="template-icon">📖</span>
                    <div class="template-title">Daily Journal</div>
                    <div class="template-description">Personal reflection and daily log format</div>
                    <div class="template-preview"># Journal Entry
📅 Date: [Today's Date]
🌤️ Mood: 
⭐ Highlights:
- 
📚 What I Learned:
- 
🎯 Tomorrow's Goals:
- </div>
                </div>
                
                <div class="template-card" data-template="project">
                    <span class="template-icon">📊</span>
                    <div class="template-title">Project Plan</div>
                    <div class="template-description">Comprehensive project planning template</div>
                    <div class="template-preview"># Project: [Name]
📅 Start: [Date] | Due: [Date]
👤 Owner: [Name]

## Objective:
[Project goal]

## Milestones:
- [ ] Phase 1: 
- [ ] Phase 2: 

## Resources:
- </div>
                </div>
                
                <div class="template-card" data-template="research">
                    <span class="template-icon">🔬</span>
                    <div class="template-title">Research Notes</div>
                    <div class="template-description">Academic and research documentation format</div>
                    <div class="template-preview"># Research: [Topic]
📅 Date: [Date]
📚 Sources:
- 

## Key Findings:
- 

## Questions:
- 

## References:
- </div>
                </div>
                
                <div class="template-card" data-template="recipe">
                    <span class="template-icon">👨‍🍳</span>
                    <div class="template-title">Recipe</div>
                    <div class="template-description">Cooking recipe with ingredients and instructions</div>
                    <div class="template-preview"># Recipe: [Name]
⏱️ Prep: [Time] | Cook: [Time]
👥 Serves: [Number]

## Ingredients:
- 

## Instructions:
1. 
2. 

## Notes:
</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Encryption Modal -->
    <div id="encryption-modal" class="encryption-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🔐 Note Security</h2>
                <button id="encryption-modal-close" class="modal-close">&times;</button>
            </div>
            
            <div class="encryption-status" id="encryption-status">
                📊 Current security level: <span id="security-level">Basic (No encryption)</span>
            </div>
            
            <div class="encryption-options">
                <div class="encryption-option" data-type="none">
                    <span class="icon">🔓</span>
                    <div class="title">No Encryption</div>
                    <div class="description">Notes stored in plain text for maximum compatibility</div>
                </div>
                
                <div class="encryption-option" data-type="basic">
                    <span class="icon">🔒</span>
                    <div class="title">Basic Encryption</div>
                    <div class="description">Simple password protection for sensitive notes</div>
                </div>
                
                <div class="encryption-option" data-type="advanced">
                    <span class="icon">🛡️</span>
                    <div class="title">Advanced Encryption</div>
                    <div class="description">Strong AES encryption with secure key derivation</div>
                </div>
            </div>
            
            <div id="password-section" style="display: none;">
                <input type="password" id="encryption-password" class="password-input" placeholder="Enter encryption password">
                <div class="password-strength" id="password-strength">
                    <div class="password-strength-bar"></div>
                </div>
                <div id="password-feedback" style="font-size: 12px; color: #666; margin-top: 5px;"></div>
                <button id="apply-encryption" style="width: 100%; padding: 12px; background: #007AFF; color: white; border: none; border-radius: 6px; margin-top: 15px; cursor: pointer;">Apply Encryption</button>
            </div>
        </div>
    </div>

    <script>
        // Tab switching functionality
        document.querySelectorAll('.section-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.section-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.notes-list, .projects-list').forEach(s => s.classList.remove('active'));
                tab.classList.add('active');
                const section = tab.getAttribute('data-section');
                document.getElementById(`${section}-list`).classList.add('active');
                toggleSelectionMode(false);
            });
        });

        // DOM Elements
        const notesList = document.getElementById('notes-list');
        const notesContainer = document.getElementById('notes-container');
        const trashList = document.getElementById('trash-list');
        const projectsList = document.getElementById('projects-list');
        const noteEditor = document.getElementById('note-editor');
        const noteTitleField = document.getElementById('note-title-field');
        const newNoteBtn = document.getElementById('new-note');
        const selectModeBtn = document.getElementById('select-mode');
        const newProjectBtn = document.getElementById('new-project');
        const showAllNotesBtn = document.getElementById('show-all-notes');
        const emptyTrashBtn = document.getElementById('empty-trash');
        const editorToolbar = document.getElementById('editor-toolbar');
        const toggleFormattingBtn = document.getElementById('toggle-formatting');
        const contextMenu = document.getElementById('context-menu');
        const notesCount = document.getElementById('notes-count');
        const trashCount = document.getElementById('trash-count');
        const projectsCount = document.getElementById('projects-count');
        const searchNotesInput = document.getElementById('search-notes');

        // Bulk action elements
        const bulkActions = document.getElementById('bulk-actions');
        const bulkTrashActions = document.getElementById('bulk-trash-actions');
        const deleteSelectedBtn = document.getElementById('delete-selected');
        const cancelSelectionBtn = document.getElementById('cancel-selection');
        const restoreSelectedBtn = document.getElementById('restore-selected');
        const deleteSelectedPermanentlyBtn = document.getElementById('delete-selected-permanently');
        const cancelTrashSelectionBtn = document.getElementById('cancel-trash-selection');

        // Toolbar elements
        const boldBtn = document.getElementById('bold-btn');
        const italicBtn = document.getElementById('italic-btn');
        const underlineBtn = document.getElementById('underline-btn');
        const fontSizeSelect = document.getElementById('font-size-select');
        const alignLeftBtn = document.getElementById('align-left-btn');
        const alignCenterBtn = document.getElementById('align-center-btn');
        const alignRightBtn = document.getElementById('align-right-btn');
        const bulletBtn = document.getElementById('bullet-btn');
        const dateBtn = document.getElementById('date-btn');
        const priorityNormal = document.getElementById('priority-normal');
        const priorityLow = document.getElementById('priority-low');
        const priorityMedium = document.getElementById('priority-medium');
        const priorityHigh = document.getElementById('priority-high');
        const projectSelect = document.getElementById('project-select');
        const remindMeBtn = document.getElementById('remind-me-btn');
        const reminderDate = document.getElementById('reminder-date');
        const clearBtn = document.getElementById('clear-btn');

        // Context menu elements
        const ctxDate = document.getElementById('ctx-date');
        const ctxRemind = document.getElementById('ctx-remind');
        const ctxDeleteNote = document.getElementById('ctx-delete-note');
        const priorityRow = document.getElementById('priority-row');
        const ctxPriorityNone = document.getElementById('ctx-priority-none');
        const ctxPriorityLow = document.getElementById('ctx-priority-low');
        const ctxPriorityMedium = document.getElementById('ctx-priority-medium');
        const ctxPriorityHigh = document.getElementById('ctx-priority-high');
        const ctxRestoreNote = document.getElementById('ctx-restore-note');
        const ctxDeletePermanently = document.getElementById('ctx-delete-permanently');
        const ctxRenameProject = document.getElementById('ctx-rename-project');
        const ctxDeleteProject = document.getElementById('ctx-delete-project');

        // Notification and feedback elements
        const saveNotification = document.getElementById('save-notification');
        const autoSaveIndicator = document.getElementById('auto-save-indicator');
        const keyboardShortcutsHelp = document.getElementById('keyboard-shortcuts-help');

        // Phase 2: Export/Import elements
        const exportBtn = document.getElementById('export-btn');
        const importBtn = document.getElementById('import-btn');
        const exportModal = document.getElementById('export-modal');
        const importModal = document.getElementById('import-modal');
        const exportModalClose = document.getElementById('export-modal-close');
        const importModalClose = document.getElementById('import-modal-close');
        const importFile = document.getElementById('import-file');
        const importPreview = document.getElementById('import-preview');
        const importPreviewContent = document.getElementById('import-preview-content');

        // Phase 2: Undo/Redo elements
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const historyStatus = document.getElementById('history-status');

        // Phase 3: Advanced features elements
        const templatesBtn = document.getElementById('templates-btn');
        const encryptionBtn = document.getElementById('encryption-btn');
        const templatesModal = document.getElementById('templates-modal');
        const encryptionModal = document.getElementById('encryption-modal');
        const templatesModalClose = document.getElementById('templates-modal-close');
        const encryptionModalClose = document.getElementById('encryption-modal-close');
        const sortSelect = document.getElementById('sort-select');
        const toggleCustomOrderBtn = document.getElementById('toggle-custom-order');
        const encryptionPassword = document.getElementById('encryption-password');
        const passwordStrength = document.getElementById('password-strength');
        const passwordFeedback = document.getElementById('password-feedback');
        const applyEncryptionBtn = document.getElementById('apply-encryption');
        const encryptionStatus = document.getElementById('encryption-status');
        const securityLevel = document.getElementById('security-level');

        // App state
        let formattingEnabled = true;
        let currentNoteId = null;
        let currentProjectId = null;
        let contextNoteId = null;
        let contextTrashId = null;
        let contextProjectId = null;
        let savedFormattingContent = {};

        // Multi-select state
        let selectionMode = false;
        let selectedNoteIds = new Set();
        let selectedTrashIds = new Set();
        let reminderDateVisible = false;

        // Phase 1 improvements: Save feedback and error handling
        let saveTimeout = null;
        let keyboardShortcutsVisible = false;
        let lastSaveTime = null;
        let saveInProgress = false;

        // Phase 2: Undo/Redo system
        let undoHistory = [];
        let redoHistory = [];
        let maxHistorySize = 50;
        let historyEnabled = true;
        let lastHistoryState = null;

        // Phase 2: Export/Import system
        let exportInProgress = false;
        let importInProgress = false;

        // Phase 3: Advanced features state
        let draggedNoteId = null;
        let customOrderMode = false;
        let currentSortMode = 'updated';
        let encryptionEnabled = false;
        let encryptionType = 'none';
        let encryptionKey = null;
        let selectedTemplate = null;

        // In-memory storage
        let appData = {
            notes: {},
            trash: {},
            projects: {}
        };

        // --- DATA PERSISTENCE FUNCTIONS WITH ENHANCED ERROR HANDLING ---
        function saveData() {
            if (saveInProgress) return;
            
            try {
                saveInProgress = true;
                showAutoSaveIndicator('saving');
                
                if (!validateAppData()) {
                    throw new Error('Invalid data structure detected');
                }
                
                const dataToSave = JSON.stringify(appData);
                
                if (dataToSave.length > 4000000) {
                    showNotification('Warning: Data size is getting large', 'warning');
                }
                
                localStorage.setItem('simpleNotesData', dataToSave);
                
                lastSaveTime = new Date();
                showAutoSaveIndicator('saved');
                showNotification('✓ Notes saved successfully');
                
            } catch (error) {
                console.error('Failed to save data:', error);
                showAutoSaveIndicator('error');
                showNotification('❌ Failed to save notes: ' + error.message, 'error');
                
                if (error.name === 'QuotaExceededError') {
                    showNotification('❌ Storage full! Please export and delete old notes.', 'error');
                }
            } finally {
                saveInProgress = false;
            }
        }

        function loadData() {
            try {
                const savedData = localStorage.getItem('simpleNotesData');
                
                if (!savedData) {
                    return false;
                }
                
                const parsedData = JSON.parse(savedData);
                
                if (!validateLoadedData(parsedData)) {
                    throw new Error('Corrupted data detected');
                }
                
                appData = parsedData;
                
                if (!appData.projects) {
                    appData.projects = {};
                }
                
                appData.notes = validateAndCleanNotes(appData.notes);
                appData.trash = validateAndCleanNotes(appData.trash);
                appData.projects = validateAndCleanProjects(appData.projects);
                
                console.log('Data loaded successfully');
                showNotification('✓ Notes loaded');
                return true;
                
            } catch (error) {
                console.error('Failed to load data:', error);
                showNotification('❌ Failed to load saved notes: ' + error.message, 'error');
                
                appData = { notes: {}, trash: {}, projects: {} };
                showNotification('⚠️ Started with empty notes due to data corruption', 'warning');
                return false;
            }
        }

        // Data validation functions
        function validateAppData() {
            if (!appData || typeof appData !== 'object') return false;
            if (!appData.notes || typeof appData.notes !== 'object') return false;
            if (!appData.trash || typeof appData.trash !== 'object') return false;
            if (!appData.projects || typeof appData.projects !== 'object') return false;
            return true;
        }

        function validateLoadedData(data) {
            if (!data || typeof data !== 'object') return false;
            if (data.notes && typeof data.notes !== 'object') return false;
            if (data.trash && typeof data.trash !== 'object') return false;
            if (data.projects && typeof data.projects !== 'object') return false;
            return true;
        }

        function validateAndCleanNotes(notes) {
            if (!notes || typeof notes !== 'object') return {};
            
            const cleaned = {};
            Object.keys(notes).forEach(id => {
                const note = notes[id];
                if (note && typeof note === 'object' && note.id) {
                    cleaned[id] = {
                        id: note.id,
                        title: typeof note.title === 'string' ? note.title : '',
                        content: typeof note.content === 'string' ? note.content : '',
                        created: note.created || new Date().toISOString(),
                        updated: note.updated || new Date().toISOString(),
                        importance: ['', 'low', 'medium', 'high'].includes(note.importance) ? note.importance : '',
                        reminder: note.reminder || null,
                        projectId: note.projectId || null,
                        fontSize: note.fontSize || '16px',
                        deletedAt: note.deletedAt || null,
                        encrypted: note.encrypted || false,
                        customOrder: note.customOrder || null,
                        template: note.template || null
                    };
                }
            });
            return cleaned;
        }

        function validateAndCleanProjects(projects) {
            if (!projects || typeof projects !== 'object') return {};
            
            const cleaned = {};
            Object.keys(projects).forEach(id => {
                const project = projects[id];
                if (project && typeof project === 'object' && project.id && project.name) {
                    cleaned[id] = {
                        id: project.id,
                        name: typeof project.name === 'string' ? project.name.trim() : 'Untitled Project',
                        created: project.created || new Date().toISOString(),
                        updated: project.updated || new Date().toISOString()
                    };
                }
            });
            return cleaned;
        }

        // Clean up trash items older than 7 days
        function cleanupOldTrash() {
            const weekAgo = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000));
            let deletedCount = 0;
            Object.keys(appData.trash).forEach(noteId => {
                const note = appData.trash[noteId];
                if (note.deletedAt) {
                    const deleteDate = new Date(note.deletedAt);
                    if (deleteDate < weekAgo) {
                        delete appData.trash[noteId];
                        deletedCount++;
                    }
                } else {
                    note.deletedAt = new Date().toISOString();
                }
            });
            if (deletedCount > 0) {
                console.log(`Auto-cleanup: Permanently deleted ${deletedCount} old notes from trash`);
                saveData();
                loadTrash();
            }
            return deletedCount;
        }

        // --- NOTIFICATION SYSTEM ---
        function showNotification(message, type = 'success') {
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            saveNotification.textContent = message;
            saveNotification.className = `save-notification ${type}`;
            
            setTimeout(() => saveNotification.classList.add('show'), 10);
            
            saveTimeout = setTimeout(() => {
                saveNotification.classList.remove('show');
            }, type === 'error' ? 5000 : 3000);
        }

        function showAutoSaveIndicator(state) {
            autoSaveIndicator.className = `auto-save-indicator ${state}`;
            
            switch(state) {
                case 'saving':
                    autoSaveIndicator.textContent = '💾 Saving...';
                    break;
                case 'saved':
                    autoSaveIndicator.textContent = '✓ Saved';
                    setTimeout(() => {
                        autoSaveIndicator.classList.remove('saved');
                    }, 2000);
                    break;
                case 'error':
                    autoSaveIndicator.textContent = '❌ Save failed';
                    setTimeout(() => {
                        autoSaveIndicator.classList.remove('error');
                    }, 5000);
                    break;
            }
        }

        // --- KEYBOARD SHORTCUTS SYSTEM ---
        function toggleKeyboardShortcutsHelp() {
            keyboardShortcutsVisible = !keyboardShortcutsVisible;
            if (keyboardShortcutsVisible) {
                keyboardShortcutsHelp.classList.add('show');
                setTimeout(() => {
                    keyboardShortcutsHelp.classList.remove('show');
                    keyboardShortcutsVisible = false;
                }, 4000);
            } else {
                keyboardShortcutsHelp.classList.remove('show');
            }
        }

        function handleKeyboardShortcuts(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case 'n':
                        e.preventDefault();
                        newNoteBtn.click();
                        showNotification('📝 New note created');
                        break;
                    case 's':
                        e.preventDefault();
                        if (currentNoteId) {
                            saveCurrentNote();
                            showNotification('💾 Note saved manually');
                        } else {
                            showNotification('⚠️ No note selected to save', 'warning');
                        }
                        break;
                    case 'f':
                        e.preventDefault();
                        searchNotesInput.focus();
                        searchNotesInput.select();
                        showNotification('🔍 Search focused');
                        break;
                    case 'z':
                        e.preventDefault();
                        if (e.shiftKey) {
                            redoAction();
                        } else {
                            undoAction();
                        }
                        break;
                    case 'y':
                        e.preventDefault();
                        redoAction();
                        break;
                    case 'e':
                        e.preventDefault();
                        exportBtn.click();
                        break;
                    case 't':
                        e.preventDefault();
                        templatesBtn.click();
                        break;
                    case 'k':
                        e.preventDefault();
                        encryptionBtn.click();
                        break;
                    case '/':
                    case '?':
                        e.preventDefault();
                        toggleKeyboardShortcutsHelp();
                        break;
                    default:
                        return;
                }
            } else {
                switch(e.key) {
                    case 'Delete':
                        if (selectionMode && (selectedNoteIds.size > 0 || selectedTrashIds.size > 0)) {
                            e.preventDefault();
                            if (selectedNoteIds.size > 0) {
                                deleteSelectedBtn.click();
                            } else if (selectedTrashIds.size > 0) {
                                deleteSelectedPermanentlyBtn.click();
                            }
                        }
                        break;
                    case 'Escape':
                        if (selectionMode) {
                            e.preventDefault();
                            toggleSelectionMode(false);
                            showNotification('Selection mode cancelled');
                        } else if (keyboardShortcutsVisible) {
                            keyboardShortcutsHelp.classList.remove('show');
                            keyboardShortcutsVisible = false;
                        } else if (exportModal.classList.contains('show')) {
                            closeExportModal();
                        } else if (importModal.classList.contains('show')) {
                            closeImportModal();
                        } else if (encryptionModal.classList.contains('show')) {
                            closeEncryptionModal();
                        } else if (templatesModal.classList.contains('show')) {
                            closeTemplatesModal();
                        }
                        break;
                }
            }
        }

        // --- PHASE 2: UNDO/REDO SYSTEM ---
        function captureHistoryState() {
            if (!historyEnabled || !currentNoteId || !appData.notes[currentNoteId]) {
                return;
            }
            
            const note = appData.notes[currentNoteId];
            const currentState = {
                noteId: currentNoteId,
                title: note.title,
                content: note.content,
                timestamp: Date.now()
            };
            
            if (lastHistoryState && 
                lastHistoryState.title === currentState.title && 
                lastHistoryState.content === currentState.content) {
                return;
            }
            
            undoHistory.push(currentState);
            
            if (undoHistory.length > maxHistorySize) {
                undoHistory.shift();
            }
            
            redoHistory = [];
            
            lastHistoryState = {...currentState};
            updateHistoryUI();
        }

        function undoAction() {
            if (undoHistory.length === 0 || !currentNoteId) {
                showNotification('⚠️ Nothing to undo', 'warning');
                return;
            }
            
            if (appData.notes[currentNoteId]) {
                const note = appData.notes[currentNoteId];
                redoHistory.push({
                    noteId: currentNoteId,
                    title: note.title,
                    content: note.content,
                    timestamp: Date.now()
                });
            }
            
            const previousState = undoHistory.pop();
            
            historyEnabled = false;
            
            if (previousState.noteId === currentNoteId) {
                const note = appData.notes[currentNoteId];
                note.title = previousState.title;
                note.content = previousState.content;
                
                noteTitleField.value = previousState.title;
                noteEditor.innerHTML = DOMPurify.sanitize(previousState.content);
                
                saveData();
                loadNotes();
                
                showNotification('↶ Undid last change');
            }
            
            historyEnabled = true;
            updateHistoryUI();
        }

        function redoAction() {
            if (redoHistory.length === 0 || !currentNoteId) {
                showNotification('⚠️ Nothing to redo', 'warning');
                return;
            }
            
            if (appData.notes[currentNoteId]) {
                const note = appData.notes[currentNoteId];
                undoHistory.push({
                    noteId: currentNoteId,
                    title: note.title,
                    content: note.content,
                    timestamp: Date.now()
                });
            }
            
            const nextState = redoHistory.pop();
            
            historyEnabled = false;
            
            if (nextState.noteId === currentNoteId) {
                const note = appData.notes[currentNoteId];
                note.title = nextState.title;
                note.content = nextState.content;
                
                noteTitleField.value = nextState.title;
                noteEditor.innerHTML = DOMPurify.sanitize(nextState.content);
                
                saveData();
                loadNotes();
                
                showNotification('↷ Redid last change');
            }
            
            historyEnabled = true;
            updateHistoryUI();
        }

        function updateHistoryUI() {
            undoBtn.disabled = undoHistory.length === 0;
            redoBtn.disabled = redoHistory.length === 0;
            
            if (undoHistory.length === 0 && redoHistory.length === 0) {
                historyStatus.textContent = 'No history';
            } else {
                historyStatus.textContent = `${undoHistory.length} undo, ${redoHistory.length} redo`;
            }
        }

        function clearHistoryForNote(noteId) {
            undoHistory = undoHistory.filter(state => state.noteId !== noteId);
            redoHistory = redoHistory.filter(state => state.noteId !== noteId);
            updateHistoryUI();
        }

        // --- PHASE 2: EXPORT/IMPORT SYSTEM ---
        function openExportModal() {
            exportModal.classList.add('show');
        }

        function closeExportModal() {
            exportModal.classList.remove('show');
        }

        function openImportModal() {
            importModal.classList.add('show');
        }

        function closeImportModal() {
            importModal.classList.remove('show');
            importFile.value = '';
            importPreview.style.display = 'none';
        }

        function getExportScope() {
            const selectedScope = document.querySelector('input[name="export-scope"]:checked');
            return selectedScope ? selectedScope.value : 'all';
        }

        function prepareExportData(scope) {
            let data = {};
            
            switch(scope) {
                case 'all':
                    data = {
                        notes: appData.notes,
                        projects: appData.projects,
                        exported: new Date().toISOString(),
                        version: '1.0'
                    };
                    break;
                case 'current-project':
                    if (currentProjectId) {
                        const projectNotes = {};
                        Object.values(appData.notes).forEach(note => {
                            if (note.projectId === currentProjectId) {
                                projectNotes[note.id] = note;
                            }
                        });
                        data = {
                            notes: projectNotes,
                            projects: { [currentProjectId]: appData.projects[currentProjectId] },
                            exported: new Date().toISOString(),
                            version: '1.0'
                        };
                    } else {
                        throw new Error('No project selected');
                    }
                    break;
                case 'current-note':
                    if (currentNoteId && appData.notes[currentNoteId]) {
                        data = {
                            notes: { [currentNoteId]: appData.notes[currentNoteId] },
                            projects: {},
                            exported: new Date().toISOString(),
                            version: '1.0'
                        };
                    } else {
                        throw new Error('No note selected');
                    }
                    break;
            }
            
            return data;
        }

        function exportToJSON(scope) {
            try {
                const data = prepareExportData(scope);
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                
                const filename = `simple-notes-${scope}-${new Date().toISOString().split('T')[0]}.json`;
                downloadFile(blob, filename);
                
                showNotification(`✓ Exported ${Object.keys(data.notes).length} notes to JSON`);
                
            } catch (error) {
                showNotification('❌ Export failed: ' + error.message, 'error');
            }
        }

        function exportToMarkdown(scope) {
            try {
                const data = prepareExportData(scope);
                let markdown = `# Simple Notes Export\n\n`;
                markdown += `Exported: ${data.exported}\n`;
                markdown += `Notes: ${Object.keys(data.notes).length}\n\n`;
                
                if (Object.keys(data.projects).length > 0) {
                    markdown += `## Projects\n\n`;
                    Object.values(data.projects).forEach(project => {
                        markdown += `- **${project.name}** (Created: ${new Date(project.created).toLocaleDateString()})\n`;
                    });
                    markdown += `\n`;
                }
                
                markdown += `## Notes\n\n`;
                Object.values(data.notes).forEach(note => {
                    markdown += `### ${note.title || 'Untitled Note'}\n\n`;
                    markdown += `**Created:** ${new Date(note.created).toLocaleDateString()}\n`;
                    markdown += `**Updated:** ${new Date(note.updated).toLocaleDateString()}\n`;
                    if (note.importance) {
                        markdown += `**Priority:** ${note.importance.charAt(0).toUpperCase() + note.importance.slice(1)}\n`;
                    }
                    if (note.reminder) {
                        markdown += `**Reminder:** ${new Date(note.reminder).toLocaleDateString()}\n`;
                    }
                    markdown += `\n${note.content || 'No content'}\n\n---\n\n`;
                });
                
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const filename = `simple-notes-${scope}-${new Date().toISOString().split('T')[0]}.md`;
                downloadFile(blob, filename);
                
                showNotification(`✓ Exported ${Object.keys(data.notes).length} notes to Markdown`);
                
            } catch (error) {
                showNotification('❌ Export failed: ' + error.message, 'error');
            }
        }

        function exportToText(scope) {
            try {
                const data = prepareExportData(scope);
                let text = `SIMPLE NOTES EXPORT\n`;
                text += `==================\n\n`;
                text += `Exported: ${data.exported}\n`;
                text += `Notes: ${Object.keys(data.notes).length}\n\n`;
                
                Object.values(data.notes).forEach(note => {
                    text += `${note.title || 'Untitled Note'}\n`;
                    text += `${'-'.repeat((note.title || 'Untitled Note').length)}\n`;
                    text += `Created: ${new Date(note.created).toLocaleDateString()}\n`;
                    text += `Updated: ${new Date(note.updated).toLocaleDateString()}\n`;
                    if (note.importance) {
                        text += `Priority: ${note.importance.charAt(0).toUpperCase() + note.importance.slice(1)}\n`;
                    }
                    if (note.reminder) {
                        text += `Reminder: ${new Date(note.reminder).toLocaleDateString()}\n`;
                    }
                    text += `\n${note.content || 'No content'}\n\n`;
                    text += `${'='.repeat(50)}\n\n`;
                });
                
                const blob = new Blob([text], { type: 'text/plain' });
                const filename = `simple-notes-${scope}-${new Date().toISOString().split('T')[0]}.txt`;
                downloadFile(blob, filename);
                
                showNotification(`✓ Exported ${Object.keys(data.notes).length} notes to Text`);
                
            } catch (error) {
                showNotification('❌ Export failed: ' + error.message, 'error');
            }
        }

        function exportToHTML(scope) {
            try {
                const data = prepareExportData(scope);
                let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Notes Export</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; line-height: 1.6; }
        .header { border-bottom: 2px solid #ddd; padding-bottom: 20px; margin-bottom: 30px; }
        .note { border: 1px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 20px; }
        .note-title { font-size: 24px; font-weight: 600; margin-bottom: 10px; }
        .note-meta { font-size: 14px; color: #666; margin-bottom: 15px; }
        .note-content { margin-top: 15px; }
        .priority { padding: 2px 8px; border-radius: 12px; font-size: 12px; color: white; }
        .priority.low { background: #28a745; }
        .priority.medium { background: #ffc107; color: #333; }
        .priority.high { background: #dc3545; }
    </style>
</head>
<body>
    <div class="header">
        <h1>📝 Simple Notes Export</h1>
        <p>Exported: ${data.exported}</p>
        <p>Notes: ${Object.keys(data.notes).length}</p>
    </div>
`;
                
                Object.values(data.notes).forEach(note => {
                    html += `
    <div class="note">
        <div class="note-title">${note.title || 'Untitled Note'}</div>
        <div class="note-meta">
            Created: ${new Date(note.created).toLocaleDateString()} | 
            Updated: ${new Date(note.updated).toLocaleDateString()}`;
            
                    if (note.importance) {
                        html += ` | <span class="priority ${note.importance}">${note.importance.charAt(0).toUpperCase() + note.importance.slice(1)}</span>`;
                    }
                    if (note.reminder) {
                        html += ` | 📅 Reminder: ${new Date(note.reminder).toLocaleDateString()}`;
                    }
                    
                    html += `
        </div>
        <div class="note-content">${note.content || 'No content'}</div>
    </div>`;
                });
                
                html += `
</body>
</html>`;
                
                const blob = new Blob([html], { type: 'text/html' });
                const filename = `simple-notes-${scope}-${new Date().toISOString().split('T')[0]}.html`;
                downloadFile(blob, filename);
                
                showNotification(`✓ Exported ${Object.keys(data.notes).length} notes to HTML`);
                
            } catch (error) {
                showNotification('❌ Export failed: ' + error.message, 'error');
            }
        }

        function downloadFile(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function handleImportFile() {
            const files = importFile.files;
            if (files.length === 0) return;
            
            let importData = { notes: {}, projects: {} };
            let processedFiles = 0;
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const fileExtension = file.name.split('.').pop().toLowerCase();
                        
                        switch(fileExtension) {
                            case 'json':
                                const jsonData = JSON.parse(content);
                                if (jsonData.notes) {
                                    Object.assign(importData.notes, jsonData.notes);
                                }
                                if (jsonData.projects) {
                                    Object.assign(importData.projects, jsonData.projects);
                                }
                                break;
                            default:
                                const noteId = Date.now().toString() + '-' + processedFiles;
                                importData.notes[noteId] = {
                                    id: noteId,
                                    title: file.name,
                                    content: content,
                                    created: new Date().toISOString(),
                                    updated: new Date().toISOString(),
                                    importance: '',
                                    reminder: null,
                                    projectId: null
                                };
                                break;
                        }
                        
                        processedFiles++;
                        
                        if (processedFiles === files.length) {
                            showImportPreview(importData);
                        }
                        
                    } catch (error) {
                        showNotification(`❌ Failed to parse ${file.name}: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            });
        }

        function showImportPreview(importData) {
            const noteCount = Object.keys(importData.notes).length;
            const projectCount = Object.keys(importData.projects).length;
            
            importPreviewContent.innerHTML = `
                <strong>Import Preview:</strong><br>
                📝 ${noteCount} notes<br>
                📁 ${projectCount} projects<br><br>
                <em>Choose how to import these items...</em>
            `;
            
            importPreview.style.display = 'block';
            window.pendingImportData = importData;
        }

        function importData(mode) {
            if (!window.pendingImportData) {
                showNotification('⚠️ No import data available', 'warning');
                return;
            }
            
            try {
                const importData = window.pendingImportData;
                let noteCount = 0;
                let projectCount = 0;
                
                if (mode === 'replace') {
                    if (!confirm('⚠️ This will replace ALL existing notes and projects. Continue?')) {
                        return;
                    }
                    appData.notes = {};
                    appData.projects = {};
                    appData.trash = {};
                }
                
                Object.values(importData.projects || {}).forEach(project => {
                    const projectId = project.id || Date.now().toString() + '-proj-' + projectCount;
                    appData.projects[projectId] = {
                        ...project,
                        id: projectId,
                        updated: new Date().toISOString()
                    };
                    projectCount++;
                });
                
                Object.values(importData.notes || {}).forEach(note => {
                    const noteId = note.id || Date.now().toString() + '-note-' + noteCount;
                    appData.notes[noteId] = {
                        ...note,
                        id: noteId,
                        updated: new Date().toISOString()
                    };
                    noteCount++;
                });
                
                saveData();
                loadNotes();
                loadProjects();
                loadTrash();
                updateProjectSelect();
                
                closeImportModal();
                delete window.pendingImportData;
                
                showNotification(`✓ Imported ${noteCount} notes and ${projectCount} projects`);
                
            } catch (error) {
                showNotification('❌ Import failed: ' + error.message, 'error');
            }
        }

        // --- PHASE 3: TEMPLATES SYSTEM ---
        const noteTemplates = {
            meeting: {
                title: "Meeting Notes - [Insert Topic]",
                content: `<h1>Meeting: [Insert Topic]</h1>
<p>📅 <strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
<p>⏰ <strong>Time:</strong> [Insert Time]</p>
<p>👥 <strong>Attendees:</strong></p>
<ul>
<li>[Name 1]</li>
<li>[Name 2]</li>
</ul>

<h2>📋 Agenda</h2>
<ol>
<li>[Agenda Item 1]</li>
<li>[Agenda Item 2]</li>
</ol>

<h2>💡 Key Discussion Points</h2>
<ul>
<li>[Point 1]</li>
<li>[Point 2]</li>
</ul>

<h2>✅ Action Items</h2>
<ul>
<li>[ ] [Action 1] - [Assigned to] - [Due date]</li>
<li>[ ] [Action 2] - [Assigned to] - [Due date]</li>
</ul>

<h2>📝 Additional Notes</h2>
<p>[Any additional notes or decisions made]</p>`
            },
            
            todo: {
                title: "To-Do List - [Project Name]",
                content: `<h1>To-Do: [Project Name]</h1>
<p>📅 <strong>Created:</strong> ${new Date().toLocaleDateString()}</p>
<p>🎯 <strong>Priority:</strong> [High/Medium/Low]</p>
<p>⏰ <strong>Due Date:</strong> [Insert Date]</p>

<h2>🎯 Objective</h2>
<p>[What you want to accomplish]</p>

<h2>✅ Tasks</h2>
<ul>
<li>[ ] [Task 1]</li>
<li>[ ] [Task 2]</li>
<li>[ ] [Task 3]</li>
<li>[ ] [Task 4]</li>
</ul>

<h2>📚 Resources Needed</h2>
<ul>
<li>[Resource 1]</li>
<li>[Resource 2]</li>
</ul>

<h2>📝 Notes</h2>
<p>[Additional notes and considerations]</p>`
            },
            
            journal: {
                title: `Daily Journal - ${new Date().toLocaleDateString()}`,
                content: `<h1>Journal Entry</h1>
<p>📅 <strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
<p>🌤️ <strong>Mood:</strong> [How are you feeling today?]</p>
<p>⭐ <strong>Energy Level:</strong> [1-10]</p>

<h2>🌟 Today's Highlights</h2>
<ul>
<li>[Highlight 1]</li>
<li>[Highlight 2]</li>
<li>[Highlight 3]</li>
</ul>

<h2>📚 What I Learned</h2>
<p>[New insights, lessons, or knowledge gained]</p>

<h2>🤔 Reflections</h2>
<p>[What went well? What could be improved?]</p>

<h2>🎯 Tomorrow's Goals</h2>
<ul>
<li>[ ] [Goal 1]</li>
<li>[ ] [Goal 2]</li>
<li>[ ] [Goal 3]</li>
</ul>

<h2>🙏 Gratitude</h2>
<p>[Three things you're grateful for today]</p>`
            },
            
            project: {
                title: "Project Plan - [Project Name]",
                content: `<h1>Project: [Project Name]</h1>
<p>📅 <strong>Start Date:</strong> ${new Date().toLocaleDateString()}</p>
<p>🎯 <strong>Target Completion:</strong> [Insert Date]</p>
<p>👤 <strong>Project Owner:</strong> [Your Name]</p>
<p>💰 <strong>Budget:</strong> [If applicable]</p>

<h2>🎯 Project Objective</h2>
<p>[Clear description of what you want to achieve]</p>

<h2>🎯 Success Criteria</h2>
<ul>
<li>[Criteria 1]</li>
<li>[Criteria 2]</li>
<li>[Criteria 3]</li>
</ul>

<h2>📋 Major Milestones</h2>
<ol>
<li>[ ] <strong>Phase 1:</strong> [Description] - [Date]</li>
<li>[ ] <strong>Phase 2:</strong> [Description] - [Date]</li>
<li>[ ] <strong>Phase 3:</strong> [Description] - [Date]</li>
</ol>

<h2>📚 Resources Required</h2>
<ul>
<li>[Resource 1]</li>
<li>[Resource 2]</li>
<li>[Resource 3]</li>
</ul>

<h2>⚠️ Potential Risks</h2>
<ul>
<li>[Risk 1] - [Mitigation strategy]</li>
<li>[Risk 2] - [Mitigation strategy]</li>
</ul>

<h2>📈 Progress Tracking</h2>
<p>[How will you measure progress?]</p>`
            },
            
            research: {
                title: "Research Notes - [Topic]",
                content: `<h1>Research: [Research Topic]</h1>
<p>📅 <strong>Date:</strong> ${new Date().toLocaleDateString()}</p>
<p>🎓 <strong>Field:</strong> [Academic/Professional Field]</p>
<p>❓ <strong>Research Question:</strong> [What are you trying to find out?]</p>

<h2>📚 Sources</h2>
<ol>
<li>[Source 1] - [Author, Title, Date]</li>
<li>[Source 2] - [Author, Title, Date]</li>
<li>[Source 3] - [Author, Title, Date]</li>
</ol>

<h2>🔍 Key Findings</h2>
<ul>
<li><strong>Finding 1:</strong> [Description] (Source: [Reference])</li>
<li><strong>Finding 2:</strong> [Description] (Source: [Reference])</li>
<li><strong>Finding 3:</strong> [Description] (Source: [Reference])</li>
</ul>

<h2>💡 Analysis & Insights</h2>
<p>[Your analysis of the findings and what they mean]</p>

<h2>❓ Outstanding Questions</h2>
<ul>
<li>[Question 1]</li>
<li>[Question 2]</li>
<li>[Question 3]</li>
</ul>

<h2>🔗 Related Topics</h2>
<ul>
<li>[Related Topic 1]</li>
<li>[Related Topic 2]</li>
</ul>

<h2>📖 References</h2>
<p>[Full citations in your preferred format]</p>`
            },
            
            recipe: {
                title: "Recipe - [Dish Name]",
                content: `<h1>Recipe: [Dish Name]</h1>
<p>⏱️ <strong>Prep Time:</strong> [X minutes]</p>
<p>🔥 <strong>Cook Time:</strong> [X minutes]</p>
<p>👥 <strong>Serves:</strong> [X people]</p>
<p>🌟 <strong>Difficulty:</strong> [Easy/Medium/Hard]</p>

<h2>🛒 Ingredients</h2>
<ul>
<li>[Amount] [Ingredient 1]</li>
<li>[Amount] [Ingredient 2]</li>
<li>[Amount] [Ingredient 3]</li>
<li>[Amount] [Ingredient 4]</li>
</ul>

<h2>🔧 Equipment Needed</h2>
<ul>
<li>[Equipment 1]</li>
<li>[Equipment 2]</li>
</ul>

<h2>👨‍🍳 Instructions</h2>
<ol>
<li>[Step 1 - Be specific about temperature, timing, etc.]</li>
<li>[Step 2]</li>
<li>[Step 3]</li>
<li>[Step 4]</li>
</ol>

<h2>💡 Tips & Variations</h2>
<ul>
<li>[Tip 1]</li>
<li>[Variation 1]</li>
</ul>

<h2>📝 Notes</h2>
<p>[Personal notes, modifications, or improvements]</p>`
            }
        };

        function openTemplatesModal() {
            templatesModal.classList.add('show');
        }

        function closeTemplatesModal() {
            templatesModal.classList.remove('show');
            selectedTemplate = null;
        }

        function createNoteFromTemplate(templateType) {
            try {
                const template = noteTemplates[templateType];
                if (!template) {
                    showNotification('❌ Template not found', 'error');
                    return;
                }

                const id = Date.now().toString();
                const newNote = {
                    id: id,
                    title: template.title,
                    content: template.content,
                    created: new Date().toISOString(),
                    updated: new Date().toISOString(),
                    importance: "",
                    reminder: null,
                    projectId: currentProjectId || null,
                    template: templateType
                };

                appData.notes[id] = newNote;
                saveData();
                loadNotes();
                openNote(id);
                
                closeTemplatesModal();
                showNotification(`✓ Created note from ${templateType} template`);
                
                setTimeout(() => {
                    noteTitleField.focus();
                    noteTitleField.select();
                }, 100);
                
            } catch (error) {
                showNotification('❌ Failed to create template: ' + error.message, 'error');
            }
        }

        // --- PHASE 3: DRAG AND DROP SYSTEM ---
        function enableCustomOrder() {
            customOrderMode = true;
            currentSortMode = 'custom';
            sortSelect.value = 'custom';
            toggleCustomOrderBtn.classList.add('active');
            toggleCustomOrderBtn.textContent = '📌 Exit Custom Order';
            notesList.classList.add('custom-order-mode');
            
            document.querySelectorAll('.note-item').forEach(addDragFunctionality);
            
            showNotification('🎯 Custom order enabled - drag notes to reorder');
        }

        function disableCustomOrder() {
            customOrderMode = false;
            toggleCustomOrderBtn.classList.remove('active');
            toggleCustomOrderBtn.textContent = '📌 Custom Order';
            notesList.classList.remove('custom-order-mode');
            
            document.querySelectorAll('.drag-handle').forEach(handle => handle.remove());
            
            currentSortMode = 'updated';
            sortSelect.value = 'updated';
            loadNotes();
            
            showNotification('📋 Returned to automatic sorting');
        }

        function addDragFunctionality(noteItem) {
            if (!customOrderMode) return;
            
            if (!noteItem.querySelector('.drag-handle')) {
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.textContent = '⋮⋮';
                dragHandle.draggable = true;
                noteItem.appendChild(dragHandle);
                
                noteItem.draggable = true;
                
                noteItem.addEventListener('dragstart', handleDragStart);
                noteItem.addEventListener('dragover', handleDragOver);
                noteItem.addEventListener('dragenter', handleDragEnter);
                noteItem.addEventListener('dragleave', handleDragLeave);
                noteItem.addEventListener('drop', handleDrop);
                noteItem.addEventListener('dragend', handleDragEnd);
            }
        }

        function handleDragStart(e) {
            const noteId = getNoteIdFromElement(e.target);
            if (noteId) {
                draggedNoteId = noteId;
                e.target.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/html', e.target.outerHTML);
            }
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const noteItem = e.target.closest('.note-item');
            if (noteItem && !noteItem.classList.contains('dragging')) {
                noteItem.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const noteItem = e.target.closest('.note-item');
            if (noteItem) {
                noteItem.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const dropTargetNoteItem = e.target.closest('.note-item');
            const dropTargetId = getNoteIdFromElement(dropTargetNoteItem);
            
            if (draggedNoteId && dropTargetId && draggedNoteId !== dropTargetId) {
                reorderNotes(draggedNoteId, dropTargetId);
                showNotification('📋 Note order updated');
            }
            
            document.querySelectorAll('.note-item').forEach(item => {
                item.classList.remove('drag-over', 'dragging');
            });
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.note-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedNoteId = null;
        }

        function getNoteIdFromElement(element) {
            const noteItem = element.closest('.note-item');
            if (!noteItem) return null;
            
            const titleElement = noteItem.querySelector('.note-title');
            if (!titleElement) return null;
            
            const noteTitle = titleElement.textContent;
            const noteSubtitle = noteItem.querySelector('.note-subtitle')?.textContent;
            
            for (const [id, note] of Object.entries(appData.notes)) {
                const displayTitle = note.title || 'Untitled Note';
                const displaySubtitle = new Date(note.updated).toLocaleString();
                
                if (displayTitle === noteTitle && displaySubtitle === noteSubtitle) {
                    return id;
                }
            }
            return null;
        }

        function reorderNotes(draggedId, targetId) {
            const notes = Object.values(appData.notes);
            const draggedNote = appData.notes[draggedId];
            const targetNote = appData.notes[targetId];
            
            if (!draggedNote || !targetNote) return;
            
            const now = Date.now();
            
            const notesWithOrder = notes.map(note => ({
                ...note,
                customOrder: note.customOrder || new Date(note.updated).getTime()
            })).sort((a, b) => b.customOrder - a.customOrder);
            
            const targetIndex = notesWithOrder.findIndex(n => n.id === targetId);
            const draggedIndex = notesWithOrder.findIndex(n => n.id === draggedId);
            
            if (targetIndex === -1 || draggedIndex === -1) return;
            
            if (targetIndex === 0) {
                draggedNote.customOrder = notesWithOrder[0].customOrder + 1000;
            } else {
                const aboveOrder = notesWithOrder[targetIndex - 1].customOrder;
                const belowOrder = notesWithOrder[targetIndex].customOrder;
                draggedNote.customOrder = (aboveOrder + belowOrder) / 2;
            }
            
            saveData();
            loadNotes();
        }

        // --- PHASE 3: ENCRYPTION SYSTEM ---
        async function simpleEncrypt(text, password) {
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(text);
                const passwordData = encoder.encode(password);
                
                const encrypted = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    encrypted[i] = data[i] ^ passwordData[i % passwordData.length];
                }
                
                return btoa(String.fromCharCode(...encrypted));
            } catch (error) {
                throw new Error('Encryption failed: ' + error.message);
            }
        }

        async function simpleDecrypt(encryptedText, password) {
            try {
                const encrypted = new Uint8Array(atob(encryptedText).split('').map(c => c.charCodeAt(0)));
                const encoder = new TextEncoder();
                const passwordData = encoder.encode(password);
                
                const decrypted = new Uint8Array(encrypted.length);
                for (let i = 0; i < encrypted.length; i++) {
                    decrypted[i] = encrypted[i] ^ passwordData[i % passwordData.length];
                }
                
                return new TextDecoder().decode(decrypted);
            } catch (error) {
                throw new Error('Decryption failed: Invalid password or corrupted data');
            }
        }

        function openEncryptionModal() {
            encryptionModal.classList.add('show');
            updateEncryptionUI();
        }

        function closeEncryptionModal() {
            encryptionModal.classList.remove('show');
            encryptionPassword.value = '';
            document.getElementById('password-section').style.display = 'none';
        }

        function updateEncryptionUI() {
            const statusText = encryptionEnabled ? 
                `${encryptionType.charAt(0).toUpperCase() + encryptionType.slice(1)} encryption enabled` : 
                'No encryption (Plain text storage)';
            securityLevel.textContent = statusText;
            
            document.querySelectorAll('.encryption-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.type === encryptionType) {
                    option.classList.add('selected');
                }
            });
        }

        function checkPasswordStrength(password) {
            let strength = 0;
            let feedback = [];
            
            if (password.length >= 8) strength += 1;
            else feedback.push('Use at least 8 characters');
            
            if (/[a-z]/.test(password)) strength += 1;
            else feedback.push('Include lowercase letters');
            
            if (/[A-Z]/.test(password)) strength += 1;
            else feedback.push('Include uppercase letters');
            
            if (/[0-9]/.test(password)) strength += 1;
            else feedback.push('Include numbers');
            
            if (/[^a-zA-Z0-9]/.test(password)) strength += 1;
            else feedback.push('Include special characters');
            
            const levels = ['weak', 'medium', 'strong', 'very-strong'];
            const level = Math.min(Math.floor(strength / 1.25), 3);
            
            return { level: levels[level], strength, feedback };
        }

        async function applyEncryption() {
            try {
                const selectedType = document.querySelector('.encryption-option.selected')?.dataset.type;
                if (!selectedType) {
                    showNotification('⚠️ Please select an encryption type', 'warning');
                    return;
                }
                
                if (selectedType !== 'none' && !encryptionPassword.value) {
                    showNotification('⚠️ Please enter a password', 'warning');
                    return;
                }
                
                const password = encryptionPassword.value;
                
                if (selectedType !== 'none') {
                    const strengthCheck = checkPasswordStrength(password);
                    if (strengthCheck.strength < 2) {
                        if (!confirm('Your password is weak. Continue anyway?')) {
                            return;
                        }
                    }
                }
                
                await forceApplyEncryption(selectedType, password);
                
            } catch (error) {
                showNotification('❌ Encryption failed: ' + error.message, 'error');
            }
        }

        async function forceApplyEncryption(type, password) {
            try {
                if (type === 'none') {
                    if (encryptionEnabled) {
                        for (const note of Object.values(appData.notes)) {
                            if (note.encrypted) {
                                note.title = await simpleDecrypt(note.title, encryptionKey);
                                note.content = await simpleDecrypt(note.content, encryptionKey);
                                delete note.encrypted;
                            }
                        }
                    }
                    encryptionEnabled = false;
                    encryptionType = 'none';
                    encryptionKey = null;
                } else {
                    encryptionEnabled = true;
                    encryptionType = type;
                    encryptionKey = password;
                    
                    for (const note of Object.values(appData.notes)) {
                        if (!note.encrypted) {
                            note.title = await simpleEncrypt(note.title || '', password);
                            note.content = await simpleEncrypt(note.content || '', password);
                            note.encrypted = true;
                        }
                    }
                }
                
                saveData();
                loadNotes();
                
                if (currentNoteId && appData.notes[currentNoteId]) {
                    openNote(currentNoteId);
                }
                
                closeEncryptionModal();
                showNotification(`✓ ${type === 'none' ? 'Disabled' : 'Enabled'} encryption successfully`);
                
            } catch (error) {
                showNotification('❌ Encryption error: ' + error.message, 'error');
            }
        }

        // --- PHASE 3: ENHANCED SORTING SYSTEM ---
        function sortNotes(notes, sortMode) {
            const sortedNotes = [...notes];
            
            switch(sortMode) {
                case 'created':
                    return sortedNotes.sort((a, b) => new Date(b.created) - new Date(a.created));
                case 'title':
                    return sortedNotes.sort((a, b) => {
                        const titleA = (a.title || 'Untitled Note').toLowerCase();
                        const titleB = (b.title || 'Untitled Note').toLowerCase();
                        return titleA.localeCompare(titleB);
                    });
                case 'importance':
                    const importanceOrder = { 'high': 3, 'medium': 2, 'low': 1, '': 0 };
                    return sortedNotes.sort((a, b) => {
                        const importanceA = importanceOrder[a.importance] || 0;
                        const importanceB = importanceOrder[b.importance] || 0;
                        if (importanceA !== importanceB) {
                            return importanceB - importanceA;
                        }
                        return new Date(b.updated) - new Date(a.updated);
                    });
                case 'custom':
                    return sortedNotes.sort((a, b) => {
                        const orderA = a.customOrder || new Date(a.updated).getTime();
                        const orderB = b.customOrder || new Date(b.updated).getTime();
                        return orderB - orderA;
                    });
                default:
                    return sortedNotes.sort((a, b) => new Date(b.updated) - new Date(a.updated));
            }
        }

        // --- NOTE RENDERING & MANAGEMENT ---
        function loadNotes(searchTerm = '') {
            notesContainer.innerHTML = '';
            let noteCount = 0;
            const fragment = document.createDocumentFragment();

            const notesToDisplay = Object.values(appData.notes).filter(note => {
                const titleMatch = note.title && note.title.toLowerCase().includes(searchTerm.toLowerCase());
                const contentMatch = note.content && note.content.toLowerCase().includes(searchTerm.toLowerCase());
                const matchesSearch = searchTerm === '' || titleMatch || contentMatch;
                const matchesProject = currentProjectId === null || note.projectId === currentProjectId;
                return matchesSearch && matchesProject;
            });

            const sortedNotes = sortNotes(notesToDisplay, currentSortMode);

            sortedNotes.forEach(async (note) => {
                const noteItem = document.createElement('div');
                noteItem.className = 'note-item';
                if (currentNoteId === note.id) {
                    noteItem.classList.add('active');
                }
                if (selectionMode) {
                    noteItem.classList.add('selectable');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'selection-checkbox';
                    checkbox.checked = selectedNoteIds.has(note.id);
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleNoteItemClick(e, note.id);
                    });
                    noteItem.appendChild(checkbox);
                }

                const noteTitle = document.createElement('div');
                noteTitle.className = 'note-title';
                
                let displayTitle = note.title || 'Untitled Note';
                if (note.encrypted && encryptionEnabled && encryptionKey) {
                    try {
                        displayTitle = await simpleDecrypt(note.title, encryptionKey);
                        if (!displayTitle) displayTitle = 'Untitled Note';
                    } catch (error) {
                        displayTitle = '🔒 [Encrypted Note]';
                    }
                } else if (note.encrypted) {
                    displayTitle = '🔒 [Locked Note]';
                }
                
                noteTitle.textContent = displayTitle;

                const noteSubtitle = document.createElement('div');
                noteSubtitle.className = 'note-subtitle';
                noteSubtitle.textContent = new Date(note.updated).toLocaleString();

                noteItem.appendChild(noteTitle);
                noteItem.appendChild(noteSubtitle);

                if (note.encrypted) {
                    const encryptionIndicator = document.createElement('div');
                    encryptionIndicator.className = 'encrypted-note-indicator';
                    encryptionIndicator.textContent = '🔒';
                    encryptionIndicator.title = 'This note is encrypted';
                    noteItem.appendChild(encryptionIndicator);
                }

                if (note.importance) {
                    const importanceDot = document.createElement('div');
                    importanceDot.className = `importance-dot ${note.importance}`;
                    noteItem.appendChild(importanceDot);
                }

                if (note.reminder) {
                    const reminderIndicator = document.createElement('div');
                    reminderIndicator.className = 'reminder-indicator';
                    const reminderDateObj = new Date(note.reminder);
                    const now = new Date();
                    now.setHours(0, 0, 0, 0);

                    if (reminderDateObj < now) {
                        reminderIndicator.classList.add('reminder-overdue');
                        reminderIndicator.textContent = `📅 Overdue: ${reminderDateObj.toLocaleDateString()}`;
                    } else {
                        reminderIndicator.textContent = `📅 Reminder: ${reminderDateObj.toLocaleDateString()}`;
                    }
                    noteItem.appendChild(reminderIndicator);
                }

                if (customOrderMode) {
                    addDragFunctionality(noteItem);
                }

                noteItem.addEventListener('click', (e) => {
                    handleNoteItemClick(e, note.id);
                });
                noteItem.addEventListener('contextmenu', (e) => {
                    handleContextMenu(e, note.id, 'note');
                });

                fragment.appendChild(noteItem);
                noteCount++;
            });
            
            notesContainer.appendChild(fragment);
            notesCount.textContent = noteCount;
            updateSelectionUI();
        }

        function handleNoteItemClick(e, id) {
            if (selectionMode) {
                const checkbox = e.currentTarget.querySelector('.selection-checkbox');
                if (selectedNoteIds.has(id)) {
                    selectedNoteIds.delete(id);
                    e.currentTarget.classList.remove('selected');
                    if (checkbox) checkbox.checked = false;
                } else {
                    selectedNoteIds.add(id);
                    e.currentTarget.classList.add('selected');
                    if (checkbox) checkbox.checked = true;
                }
                updateSelectionUI();
            } else {
                document.querySelectorAll('.note-item.active').forEach(item => item.classList.remove('active'));
                document.querySelectorAll('.project-item.active').forEach(item => item.classList.remove('active'));
                openNote(id);
            }
        }

        function openNote(id) {
            if (currentNoteId && currentNoteId !== id) {
                clearHistoryForNote(currentNoteId);
            }
            
            currentNoteId = id;
            const note = appData.notes[id];

            if (note) {
                if (note.encrypted && encryptionEnabled && encryptionKey) {
                    try {
                        simpleDecrypt(note.title, encryptionKey).then(decryptedTitle => {
                            noteTitleField.value = decryptedTitle || '';
                        }).catch(() => {
                            noteTitleField.value = '[Decryption Error]';
                        });
                        
                        simpleDecrypt(note.content, encryptionKey).then(decryptedContent => {
                            noteEditor.innerHTML = DOMPurify.sanitize(decryptedContent || '');
                        }).catch(() => {
                            noteEditor.innerHTML = '<p style="color: red;">[Content could not be decrypted]</p>';
                        });
                    } catch (error) {
                        noteTitleField.value = '[Decryption Error]';
                        noteEditor.innerHTML = '<p style="color: red;">[Content could not be decrypted - check encryption password]</p>';
                        showNotification('🔒 Decryption failed. Check your encryption settings.', 'error');
                    }
                } else if (note.encrypted) {
                    noteTitleField.value = '[Locked Note]';
                    noteEditor.innerHTML = '<p style="color: #666; text-align: center; margin-top: 50px;">🔒 This note is encrypted.<br><br>Please set up encryption to view this content.</p>';
                    showNotification('🔒 This note is encrypted. Set up encryption to view it.', 'warning');
                } else {
                    noteTitleField.value = note.title || '';
                    noteEditor.innerHTML = DOMPurify.sanitize(note.content || '');
                }
                
                noteEditor.focus();

                document.querySelectorAll('.note-item').forEach(item => {
                    if (item.dataset.id === id) {
                        item.classList.add('active');
                    } else {
                        item.classList.remove('active');
                    }
                });

                document.querySelectorAll('.priority-btn').forEach(btn => btn.classList.remove('active', 'priority-low', 'priority-medium', 'priority-high'));
                if (note.importance) {
                    document.getElementById(`priority-${note.importance}`).classList.add('active', `priority-${note.importance}`);
                } else {
                    priorityNormal.classList.add('active');
                }

                fontSizeSelect.value = note.fontSize || '16px';
                noteEditor.style.fontSize = note.fontSize || '16px';

                updateProjectSelect(note.projectId);

                if (note.reminder) {
                    reminderDate.value = note.reminder.split('T')[0];
                    reminderDateVisible = true;
                    remindMeBtn.textContent = 'Hide Reminder';
                    reminderDate.style.display = 'inline-block';
                    reminderDate.offsetWidth;
                    reminderDate.classList.remove('reminder-date-hidden');
                    reminderDate.classList.add('reminder-date-visible');
                } else {
                    reminderDate.value = '';
                    reminderDateVisible = false;
                    remindMeBtn.textContent = '🔔 Remind Me';
                    reminderDate.classList.remove('reminder-date-visible');
                    reminderDate.classList.add('reminder-date-hidden');
                    reminderDate.addEventListener('transitionend', function handler() {
                        reminderDate.style.display = 'none';
                        reminderDate.removeEventListener('transitionend', handler);
                    }, { once: true });
                }

                updateHistoryUI();

            } else {
                currentNoteId = null;
                noteTitleField.value = '';
                noteEditor.innerHTML = '';
                noteEditor.setAttribute('data-placeholder', 'Select a note or create a new one...');
                document.querySelectorAll('.note-item').forEach(item => item.classList.remove('active'));
                reminderDateVisible = false;
                remindMeBtn.textContent = '🔔 Remind Me';
                reminderDate.classList.remove('reminder-date-visible');
                reminderDate.classList.add('reminder-date-hidden');
                reminderDate.addEventListener('transitionend', function handler() {
                    reminderDate.style.display = 'none';
                    reminderDate.removeEventListener('transitionend', handler);
                }, { once: true });
                
                updateHistoryUI();
            }
        }

        function saveCurrentNote() {
            if (!currentNoteId || !appData.notes[currentNoteId]) {
                return;
            }
            
            try {
                const note = appData.notes[currentNoteId];
                
                captureHistoryState();
                
                const title = noteTitleField.value.trim();
                const content = formattingEnabled ? 
                    DOMPurify.sanitize(noteEditor.innerHTML) : 
                    noteEditor.textContent.trim();
                
                if (title.length > 500) {
                    showNotification('⚠️ Title too long (max 500 characters)', 'warning');
                    return;
                }
                
                if (content.length > 100000) {
                    showNotification('⚠️ Content too large (max 100KB)', 'warning');
                    return;
                }
                
                if (encryptionEnabled && encryptionKey) {
                    Promise.all([
                        simpleEncrypt(title, encryptionKey),
                        simpleEncrypt(content, encryptionKey)
                    ]).then(([encryptedTitle, encryptedContent]) => {
                        note.title = encryptedTitle;
                        note.content = encryptedContent;
                        note.encrypted = true;
                        finalizeSave(note);
                    }).catch(error => {
                        showNotification('❌ Encryption failed: ' + error.message, 'error');
                    });
                } else {
                    note.title = title;
                    note.content = content;
                    if (note.encrypted) {
                        delete note.encrypted;
                    }
                    finalizeSave(note);
                }
                
            } catch (error) {
                showNotification('❌ Failed to save note: ' + error.message, 'error');
            }
        }

        function finalizeSave(note) {
            note.updated = new Date().toISOString();
            note.fontSize = fontSizeSelect.value;

            if (reminderDate.value) {
                const reminderDateValue = new Date(reminderDate.value);
                if (isNaN(reminderDateValue.getTime())) {
                    showNotification('⚠️ Invalid reminder date', 'warning');
                    reminderDate.value = '';
                    note.reminder = null;
                } else {
                    note.reminder = reminderDateValue.toISOString().split('T')[0];
                }
            } else {
                note.reminder = null;
            }

            saveData();
            loadNotes();
        }

        // --- PROJECT MANAGEMENT ---
        function loadProjects() {
            projectsList.innerHTML = '';
            let projectCount = 0;
            const fragment = document.createDocumentFragment();

            Object.values(appData.projects).sort((a, b) => a.name.localeCompare(b.name)).forEach(project => {
                const projectItem = document.createElement('div');
                projectItem.className = 'project-item';
                projectItem.dataset.projectId = project.id;

                if (currentProjectId === project.id) {
                    projectItem.classList.add('active');
                }

                const projectNameEl = document.createElement('div');
                projectNameEl.className = 'project-name';
                projectNameEl.textContent = project.name;

                const noteCountForProject = Object.values(appData.notes).filter(note => note.projectId === project.id).length;
                const projectNoteCountEl = document.createElement('span');
                projectNoteCountEl.className = 'project-note-count';
                projectNoteCountEl.textContent = noteCountForProject;

                projectNameEl.appendChild(projectNoteCountEl);
                projectItem.appendChild(projectNameEl);

                projectItem.addEventListener('click', () => {
                    toggleSelectionMode(false);
                    currentProjectId = project.id;
                    loadNotes();
                    updateActiveProject(project.id);
                    searchNotesInput.value = '';
                    document.querySelector('.section-tab[data-section="notes"]').click();
                });
                projectItem.addEventListener('contextmenu', (e) => {
                    handleContextMenu(e, project.id, 'project');
                });
                fragment.appendChild(projectItem);
                projectCount++;
            });
            projectsList.appendChild(fragment);
            projectsCount.textContent = projectCount;
        }

        function updateProjectSelect(selectedProjectId = null) {
            projectSelect.innerHTML = '<option value="">No Project</option>';
            Object.values(appData.projects).sort((a, b) => a.name.localeCompare(b.name)).forEach(project => {
                const option = document.createElement('option');
                option.value = project.id;
                option.textContent = project.name;
                projectSelect.appendChild(option);
            });
            if (selectedProjectId) {
                projectSelect.value = selectedProjectId;
            } else {
                projectSelect.value = '';
            }
        }

        function updateActiveProject(id = null) {
            document.querySelectorAll('.project-item').forEach(item => item.classList.remove('active'));
            if (id) {
                const selectedProjectItem = document.querySelector(`.project-item[data-project-id="${id}"]`);
                if (selectedProjectItem) {
                    selectedProjectItem.classList.add('active');
                }
            }
            if (id !== null) {
                showAllNotesBtn.classList.remove('active');
            } else {
                showAllNotesBtn.classList.add('active');
            }
        }

        // --- TRASH MANAGEMENT ---
        function loadTrash() {
            trashList.innerHTML = '';
            let trashCount = 0;
            const fragment = document.createDocumentFragment();

            Object.values(appData.trash).sort((a, b) => new Date(b.deletedAt || b.updated) - new Date(a.deletedAt || a.updated)).forEach(note => {
                const trashItem = document.createElement('div');
                trashItem.className = 'trash-item';
                if (selectionMode) {
                    trashItem.classList.add('selectable');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'selection-checkbox';
                    checkbox.checked = selectedTrashIds.has(note.id);
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        handleTrashItemClick(e, note.id);
                    });
                    trashItem.appendChild(checkbox);
                }

                const noteTitle = document.createElement('div');
                noteTitle.className = 'note-title';
                noteTitle.textContent = note.title || 'Untitled Note';

                const noteSubtitle = document.createElement('div');
                noteSubtitle.className = 'note-subtitle';
                noteSubtitle.textContent = `Deleted: ${new Date(note.deletedAt || note.updated).toLocaleString()}`;

                trashItem.appendChild(noteTitle);
                trashItem.appendChild(noteSubtitle);

                trashItem.addEventListener('click', (e) => {
                    handleTrashItemClick(e, note.id);
                });
                trashItem.addEventListener('contextmenu', (e) => {
                    handleContextMenu(e, note.id, 'trash');
                });
                fragment.appendChild(trashItem);
                trashCount++;
            });
            trashList.appendChild(fragment);

            const emptyTrashButtonExists = trashList.querySelector('#empty-trash');
            if (emptyTrashButtonExists) {
                trashList.removeChild(emptyTrashButtonExists);
            }
            trashList.appendChild(emptyTrashBtn);

            trashCount.textContent = trashCount;
            updateSelectionUI();
        }

        function handleTrashItemClick(e, id) {
            if (selectionMode) {
                const checkbox = e.currentTarget.querySelector('.selection-checkbox');
                if (selectedTrashIds.has(id)) {
                    selectedTrashIds.delete(id);
                    e.currentTarget.classList.remove('selected');
                    if (checkbox) checkbox.checked = false;
                } else {
                    selectedTrashIds.add(id);
                    e.currentTarget.classList.add('selected');
                    if (checkbox) checkbox.checked = true;
                }
                updateSelectionUI();
            } else {
                showNotification('⚠️ Notes in trash cannot be edited. Use right-click menu to restore or delete.', 'warning');
            }
        }

        function moveToTrash(noteId) {
            if (appData.notes[noteId]) {
                const note = appData.notes[noteId];
                note.deletedAt = new Date().toISOString();
                appData.trash[noteId] = note;
                delete appData.notes[noteId];
                saveData();
                if (currentNoteId === noteId) {
                    openNote(null);
                }
                loadNotes();
                loadTrash();
            }
        }

        function restoreNote(noteId) {
            if (appData.trash[noteId]) {
                const note = appData.trash[noteId];
                note.updated = new Date().toISOString();
                delete note.deletedAt;
                appData.notes[noteId] = note;
                delete appData.trash[noteId];
                saveData();
                loadNotes();
                loadTrash();
            }
        }

        function deleteNotePermanently(noteId) {
            if (appData.trash[noteId]) {
                delete appData.trash[noteId];
                saveData();
                loadTrash();
            }
        }

        // --- SELECTION MODE ---
        function toggleSelectionMode(forceState = null) {
            selectionMode = forceState !== null ? forceState : !selectionMode;

            if (selectionMode) {
                document.body.classList.add('selection-mode');
                document.querySelectorAll('.note-item, .trash-item').forEach(item => {
                    item.classList.add('selectable');
                    if (!item.querySelector('.selection-checkbox')) {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'selection-checkbox';
                        checkbox.addEventListener('click', (e) => {
                            e.stopPropagation();
                        });
                        item.prepend(checkbox);
                    }
                });
                selectModeBtn.textContent = '✖️ Cancel';
                selectedNoteIds.clear();
                selectedTrashIds.clear();
                document.querySelectorAll('.note-item.selected, .trash-item.selected').forEach(item => item.classList.remove('selected'));
                document.querySelectorAll('.selection-checkbox').forEach(cb => cb.checked = false);
            } else {
                document.body.classList.remove('selection-mode');
                document.querySelectorAll('.note-item, .trash-item').forEach(item => {
                    item.classList.remove('selectable', 'selected');
                    const checkbox = item.querySelector('.selection-checkbox');
                    if (checkbox) {
                        checkbox.remove();
                    }
                });
                selectModeBtn.textContent = '☑️ Select';
                selectedNoteIds.clear();
                selectedTrashIds.clear();
            }
            updateSelectionUI();
        }

        function updateSelectionUI() {
            const notesActive = document.querySelector('.section-tab[data-section="notes"]').classList.contains('active');
            const projectsActive = document.querySelector('.section-tab[data-section="projects"]').classList.contains('active');

            bulkActions.classList.remove('active');
            bulkTrashActions.classList.remove('active');

            if (selectionMode) {
                if (notesActive || projectsActive) {
                    if (selectedNoteIds.size > 0) {
                        bulkActions.classList.add('active');
                    }
                }
                if (selectedTrashIds.size > 0) {
                    bulkTrashActions.classList.add('active');
                }
            }
        }

        // --- CONTEXT MENU ---
        function handleContextMenu(e, id, type) {
            e.preventDefault();
            contextMenu.style.display = 'none';
            contextNoteId = null;
            contextTrashId = null;
            contextProjectId = null;

            document.querySelectorAll('.context-menu-item, .priority-row').forEach(item => item.style.display = 'none');

            if (type === 'note') {
                contextNoteId = id;
                ctxDate.style.display = 'block';
                ctxRemind.style.display = 'block';
                ctxDeleteNote.style.display = 'block';
                priorityRow.style.display = 'flex';
            } else if (type === 'trash') {
                contextTrashId = id;
                ctxRestoreNote.style.display = 'block';
                ctxDeletePermanently.style.display = 'block';
            } else if (type === 'project') {
                contextProjectId = id;
                ctxRenameProject.style.display = 'block';
                ctxDeleteProject.style.display = 'block';
            }

            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            contextMenu.style.display = 'block';
        }

        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

        // --- INITIALIZATION ---
        if (!loadData()) {
            console.log('No saved data found, starting fresh');
            showNotification('👋 Welcome to Simple Notes!');
        }

        loadProjects();
        loadNotes();
        loadTrash();
        cleanupOldTrash();
        updateProjectSelect();
        updateSelectionUI();

        setInterval(cleanupOldTrash, 24 * 60 * 60 * 1000);
        document.addEventListener('keydown', handleKeyboardShortcuts);
        setTimeout(() => toggleKeyboardShortcutsHelp(), 1000);

        // --- EVENT LISTENERS ---
        newNoteBtn.addEventListener('click', () => {
            try {
                toggleSelectionMode(false);
                const id = Date.now().toString();
                const newNote = {
                    id: id,
                    title: "",
                    content: "",
                    created: new Date().toISOString(),
                    updated: new Date().toISOString(),
                    importance: "",
                    reminder: null,
                    projectId: currentProjectId || null
                };
                appData.notes[id] = newNote;
                saveData();
                loadNotes();
                openNote(id);
                setTimeout(() => {
                    noteTitleField.focus();
                    noteTitleField.select();
                }, 100);
            } catch (error) {
                showNotification('❌ Failed to create new note: ' + error.message, 'error');
            }
        });

        selectModeBtn.addEventListener('click', () => {
            toggleSelectionMode();
        });

        newProjectBtn.addEventListener('click', () => {
            try {
                toggleSelectionMode(false);
                const name = prompt("Enter project name:");
                if (!name || !name.trim()) {
                    return;
                }

                const trimmedName = name.trim();
                if (trimmedName.length > 100) {
                    showNotification('⚠️ Project name too long (max 100 characters)', 'warning');
                    return;
                }
                
                const projectExists = Object.values(appData.projects).some(project => 
                    project.name.toLowerCase() === trimmedName.toLowerCase()
                );
                if (projectExists) {
                    showNotification(`⚠️ A project named "${trimmedName}" already exists.`, 'warning');
                    return;
                }

                const id = Date.now().toString();
                appData.projects[id] = {
                    id: id,
                    name: trimmedName,
                    created: new Date().toISOString(),
                    updated: new Date().toISOString()
                };
                
                saveData();
                loadProjects();
                updateProjectSelect();
                showNotification(`✓ Project "${trimmedName}" created successfully`);
                
            } catch (error) {
                showNotification('❌ Failed to create project: ' + error.message, 'error');
            }
        });

        showAllNotesBtn.addEventListener('click', () => {
            toggleSelectionMode(false);
            currentProjectId = null;
            searchNotesInput.value = '';
            loadNotes();
            updateActiveProject();
        });

        emptyTrashBtn.addEventListener('click', (e) => {
            toggleSelectionMode(false);
            if (e.shiftKey) {
                const oneMinuteAgo = new Date(Date.now() - (1 * 60 * 1000));
                let testDeletedCount = 0;
                Object.keys(appData.trash).forEach(noteId => {
                    const note = appData.trash[noteId];
                    if (note.deletedAt && new Date(note.deletedAt) < oneMinuteAgo) {
                        delete appData.trash[noteId];
                        testDeletedCount++;
                    }
                });
                if (testDeletedCount > 0) {
                    console.log(`Test cleanup: Deleted ${testDeletedCount} notes older than 1 minute`);
                    saveData();
                    loadTrash();
                } else {
                    console.log('Test cleanup: No notes older than 1 minute found');
                }
                return;
            }
            if (Object.keys(appData.trash).length === 0) {
                showNotification("Trash is already empty.", 'warning');
                return;
            }
            if (confirm("Permanently delete all notes in trash? This cannot be undone.")) {
                appData.trash = {};
                saveData();
                loadTrash();
                showNotification('✓ Trash emptied successfully');
            }
        });

        searchNotesInput.addEventListener('input', () => {
            loadNotes(searchNotesInput.value);
        });

        noteTitleField.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                noteEditor.focus();
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(noteEditor);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            }
        });

        remindMeBtn.addEventListener('click', () => {
            reminderDateVisible = !reminderDateVisible;
            if (reminderDateVisible) {
                reminderDate.style.display = 'inline-block';
                reminderDate.offsetWidth;
                reminderDate.classList.remove('reminder-date-hidden');
                reminderDate.classList.add('reminder-date-visible');
                reminderDate.focus();
                remindMeBtn.textContent = 'Hide Reminder';
            } else {
                reminderDate.classList.remove('reminder-date-visible');
                reminderDate.classList.add('reminder-date-hidden');
                reminderDate.addEventListener('transitionend', function handler() {
                    reminderDate.style.display = 'none';
                    remindMeBtn.textContent = '🔔 Remind Me';
                    reminderDate.removeEventListener('transitionend', handler);
                }, { once: true });
            }
        });

        projectSelect.addEventListener('change', () => {
            if (currentNoteId && appData.notes[currentNoteId]) {
                const selectedProjectId = projectSelect.value === '' ? null : projectSelect.value;
                appData.notes[currentNoteId].projectId = selectedProjectId;
                saveData();
                loadNotes();
                loadProjects();
            }
        });

        deleteSelectedBtn.addEventListener('click', () => {
            if (selectedNoteIds.size === 0) {
                showNotification('⚠️ No notes selected', 'warning');
                return;
            }
            
            try {
                if (confirm(`Move ${selectedNoteIds.size} selected note(s) to trash?`)) {
                    let successCount = 0;
                    selectedNoteIds.forEach(id => {
                        if (appData.notes[id]) {
                            moveToTrash(id);
                            successCount++;
                        }
                    });
                    
                    toggleSelectionMode(false);
                    saveData();
                    loadNotes();
                    loadTrash();
                    
                    showNotification(`✓ Moved ${successCount} note(s) to trash`);
                }
            } catch (error) {
                showNotification('❌ Failed to delete notes: ' + error.message, 'error');
            }
        });

        restoreSelectedBtn.addEventListener('click', () => {
            if (selectedTrashIds.size === 0) {
                showNotification('⚠️ No trash items selected', 'warning');
                return;
            }
            
            try {
                if (confirm(`Restore ${selectedTrashIds.size} selected note(s) from trash?`)) {
                    let successCount = 0;
                    selectedTrashIds.forEach(id => {
                        if (appData.trash[id]) {
                            restoreNote(id);
                            successCount++;
                        }
                    });
                    
                    toggleSelectionMode(false);
                    saveData();
                    loadNotes();
                    loadTrash();
                    
                    showNotification(`✓ Restored ${successCount} note(s) from trash`);
                }
            } catch (error) {
                showNotification('❌ Failed to restore notes: ' + error.message, 'error');
            }
        });

        deleteSelectedPermanentlyBtn.addEventListener('click', () => {
            if (selectedTrashIds.size === 0) {
                showNotification('⚠️ No trash items selected', 'warning');
                return;
            }
            
            try {
                if (confirm(`Permanently delete ${selectedTrashIds.size} selected note(s)? This cannot be undone.`)) {
                    let successCount = 0;
                    selectedTrashIds.forEach(id => {
                        if (appData.trash[id]) {
                            deleteNotePermanently(id);
                            successCount++;
                        }
                    });
                    
                    toggleSelectionMode(false);
                    saveData();
                    loadTrash();
                    
                    showNotification(`✓ Permanently deleted ${successCount} note(s)`);
                }
            } catch (error) {
                showNotification('❌ Failed to permanently delete notes: ' + error.message, 'error');
            }
        });

        cancelSelectionBtn.addEventListener('click', () => toggleSelectionMode(false));
        cancelTrashSelectionBtn.addEventListener('click', () => toggleSelectionMode(false));

        // Phase 2: Export/Import
        exportBtn.addEventListener('click', () => {
            try {
                openExportModal();
            } catch (error) {
                showNotification('❌ Failed to open export: ' + error.message, 'error');
            }
        });

        importBtn.addEventListener('click', () => {
            try {
                openImportModal();
            } catch (error) {
                showNotification('❌ Failed to open import: ' + error.message, 'error');
            }
        });

        exportModalClose.addEventListener('click', closeExportModal);
        importModalClose.addEventListener('click', closeImportModal);

        document.querySelectorAll('.export-option').forEach(option => {
            option.addEventListener('click', () => {
                try {
                    const format = option.dataset.format;
                    const scope = getExportScope();
                    
                    switch(format) {
                        case 'json':
                            exportToJSON(scope);
                            break;
                        case 'markdown':
                            exportToMarkdown(scope);
                            break;
                        case 'txt':
                            exportToText(scope);
                            break;
                        case 'html':
                            exportToHTML(scope);
                            break;
                    }
                    
                    closeExportModal();
                } catch (error) {
                    showNotification('❌ Export failed: ' + error.message, 'error');
                }
            });
        });

        importFile.addEventListener('change', handleImportFile);

        document.getElementById('import-merge').addEventListener('click', () => {
            importData('merge');
        });

        document.getElementById('import-replace').addEventListener('click', () => {
            importData('replace');
        });

        undoBtn.addEventListener('click', undoAction);
        redoBtn.addEventListener('click', redoAction);

        exportModal.addEventListener('click', (e) => {
            if (e.target === exportModal) {
                closeExportModal();
            }
        });

        importModal.addEventListener('click', (e) => {
            if (e.target === importModal) {
                closeImportModal();
            }
        });

        // Phase 3: Templates
        templatesBtn.addEventListener('click', () => {
            try {
                openTemplatesModal();
            } catch (error) {
                showNotification('❌ Failed to open templates: ' + error.message, 'error');
            }
        });

        templatesModalClose.addEventListener('click', closeTemplatesModal);

        document.querySelectorAll('.template-card').forEach(card => {
            card.addEventListener('click', () => {
                try {
                    const templateType = card.dataset.template;
                    createNoteFromTemplate(templateType);
                } catch (error) {
                    showNotification('❌ Failed to create template: ' + error.message, 'error');
                }
            });
        });

        // Phase 3: Encryption
        encryptionBtn.addEventListener('click', () => {
            try {
                openEncryptionModal();
            } catch (error) {
                showNotification('❌ Failed to open encryption: ' + error.message, 'error');
            }
        });

        encryptionModalClose.addEventListener('click', closeEncryptionModal);

        document.querySelectorAll('.encryption-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.encryption-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                
                const type = option.dataset.type;
                if (type === 'none') {
                    document.getElementById('password-section').style.display = 'none';
                } else {
                    document.getElementById('password-section').style.display = 'block';
                    encryptionPassword.focus();
                }
            });
        });

        encryptionPassword.addEventListener('input', () => {
            const password = encryptionPassword.value;
            const strengthCheck = checkPasswordStrength(password);
            
            passwordStrength.className = `password-strength ${strengthCheck.level}`;
            passwordFeedback.textContent = strengthCheck.feedback.join(', ');
        });

        applyEncryptionBtn.addEventListener('click', applyEncryption);

        // Phase 3: Sorting
        sortSelect.addEventListener('change', () => {
            currentSortMode = sortSelect.value;
            
            if (currentSortMode === 'custom') {
                enableCustomOrder();
            } else {
                if (customOrderMode) {
                    disableCustomOrder();
                }
                loadNotes();
            }
        });

        toggleCustomOrderBtn.addEventListener('click', () => {
            if (customOrderMode) {
                disableCustomOrder();
            } else {
                enableCustomOrder();
            }
        });

        templatesModal.addEventListener('click', (e) => {
            if (e.target === templatesModal) {
                closeTemplatesModal();
            }
        });

        encryptionModal.addEventListener('click', (e) => {
            if (e.target === encryptionModal) {
                closeEncryptionModal();
            }
        });

        let inputTimeout = null;
        noteTitleField.addEventListener('input', () => {
            clearTimeout(inputTimeout);
            inputTimeout = setTimeout(() => {
                saveCurrentNote();
            }, 500);
        });

        noteEditor.addEventListener('input', () => {
            clearTimeout(inputTimeout);
            inputTimeout = setTimeout(() => {
                saveCurrentNote();
            }, 1000);
        });

        fontSizeSelect.addEventListener('change', saveCurrentNote);
        reminderDate.addEventListener('change', saveCurrentNote);

        // Toolbar functionality
        toggleFormattingBtn.addEventListener('click', () => {
            formattingEnabled = !formattingEnabled;
            editorToolbar.classList.toggle('hidden', !formattingEnabled);
            toggleFormattingBtn.classList.toggle('active', formattingEnabled);
            noteEditor.contentEditable = formattingEnabled;

            if (formattingEnabled) {
                if (savedFormattingContent[currentNoteId]) {
                    noteEditor.innerHTML = DOMPurify.sanitize(savedFormattingContent[currentNoteId]);
                }
            } else {
                if (currentNoteId) {
                    savedFormattingContent[currentNoteId] = noteEditor.innerHTML;
                }
                noteEditor.textContent = noteEditor.textContent;
            }
            saveCurrentNote();
        });

        boldBtn.addEventListener('click', () => document.execCommand('bold', false, null));
        italicBtn.addEventListener('click', () => document.execCommand('italic', false, null));
        underlineBtn.addEventListener('click', () => document.execCommand('underline', false, null));
        alignLeftBtn.addEventListener('click', () => document.execCommand('justifyLeft', false, null));
        alignCenterBtn.addEventListener('click', () => document.execCommand('justifyCenter', false, null));
        alignRightBtn.addEventListener('click', () => document.execCommand('justifyRight', false, null));
        bulletBtn.addEventListener('click', () => document.execCommand('insertUnorderedList', false, null));

        dateBtn.addEventListener('click', () => {
            const now = new Date();
            const formattedDate = `${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`;
            document.execCommand('insertText', false, formattedDate);
            saveCurrentNote();
        });

        clearBtn.addEventListener('click', () => {
            document.execCommand('removeFormat', false, null);
            saveCurrentNote();
        });

        document.querySelectorAll('.priority-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (currentNoteId && appData.notes[currentNoteId]) {
                    document.querySelectorAll('.priority-btn').forEach(pb => pb.classList.remove('active', 'priority-low', 'priority-medium', 'priority-high'));

                    let importance = "";
                    if (btn.id === 'priority-low') importance = "low";
                    else if (btn.id === 'priority-medium') importance = "medium";
                    else if (btn.id === 'priority-high') importance = "high";

                    appData.notes[currentNoteId].importance = importance;

                    btn.classList.add('active');
                    if (importance) {
                        btn.classList.add(`priority-${importance}`);
                    }
                    saveCurrentNote();
                }
            });
        });

        // Context menu listeners
        ctxDate.addEventListener('click', () => {
            if (currentNoteId && appData.notes[currentNoteId]) {
                const now = new Date();
                const formattedDate = `${now.getMonth() + 1}/${now.getDate()}/${now.getFullYear()}`;
                document.execCommand('insertText', false, formattedDate);
                saveCurrentNote();
            }
            contextMenu.style.display = 'none';
        });

        ctxRemind.addEventListener('click', () => {
            if (currentNoteId && appData.notes[currentNoteId]) {
                remindMeBtn.click();
            }
            contextMenu.style.display = 'none';
        });

        ctxDeleteNote.addEventListener('click', () => {
            if (contextNoteId) {
                moveToTrash(contextNoteId);
                contextMenu.style.display = 'none';
            }
        });

        ctxRestoreNote.addEventListener('click', () => {
            if (contextTrashId) {
                restoreNote(contextTrashId);
                contextMenu.style.display = 'none';
            }
        });

        ctxDeletePermanently.addEventListener('click', () => {
            if (contextTrashId && confirm("Permanently delete this note? This cannot be undone.")) {
                deleteNotePermanently(contextTrashId);
                contextMenu.style.display = 'none';
            }
        });

        ctxRenameProject.addEventListener('click', () => {
            if (contextProjectId && appData.projects[contextProjectId]) {
                const project = appData.projects[contextProjectId];
                const newName = prompt("Enter new project name:", project.name);
                if (newName && newName.trim() && newName.trim() !== project.name) {
                    const trimmedNewName = newName.trim();
                    const projectExists = Object.values(appData.projects).some(
                        p => p.id !== contextProjectId && p.name.toLowerCase() === trimmedNewName.toLowerCase()
                    );
                    if (projectExists) {
                        showNotification(`⚠️ A project named "${trimmedNewName}" already exists.`, 'warning');
                        return;
                    }

                    project.name = trimmedNewName;
                    project.updated = new Date().toISOString();
                    saveData();
                    loadProjects();
                    updateProjectSelect();
                    showNotification(`✓ Project renamed to "${trimmedNewName}"`);
                }
            }
            contextMenu.style.display = 'none';
        });

        ctxDeleteProject.addEventListener('click', () => {
            if (contextProjectId && appData.projects[contextProjectId]) {
                const project = appData.projects[contextProjectId];
                if (confirm(`Are you sure you want to delete the project "${project.name}"? All notes assigned to this project will become unassigned.`)) {
                    Object.values(appData.notes).forEach(note => {
                        if (note.projectId === contextProjectId) {
                            note.projectId = null;
                        }
                    });
                    delete appData.projects[contextProjectId];
                    saveData();
                    loadProjects();
                    loadNotes();
                    updateProjectSelect();
                    if (currentProjectId === contextProjectId) {
                        currentProjectId = null;
                        loadNotes();
                        updateActiveProject();
                    }
                    showNotification(`✓ Project "${project.name}" deleted`);
                }
            }
            contextMenu.style.display = 'none';
        });

        priorityRow.addEventListener('click', (e) => {
            const targetId = e.target.id;
            let importance = "";
            if (targetId.includes('ctx-priority-low')) importance = "low";
            else if (targetId.includes('ctx-priority-medium')) importance = "medium";
            else if (targetId.includes('ctx-priority-high')) importance = "high";

            if (currentNoteId && appData.notes[currentNoteId]) {
                appData.notes[currentNoteId].importance = importance;
                saveCurrentNote();
            }
            contextMenu.style.display = 'none';
        });

        toggleFormattingBtn.classList.add('active');
        showAllNotesBtn.classList.add('active');

        console.log('🎉 Simple Notes App - Complete Edition Ready!');
        console.log('✨ All Features Implemented:');
        console.log('  📝 Rich note editing with formatting');
        console.log('  📋 Professional templates (6 types)');
        console.log('  🎯 Drag-and-drop custom ordering');
        console.log('  📊 Advanced sorting options');
        console.log('  🔐 Encryption system (Basic & Advanced)');
        console.log('  📤 Export (JSON, Markdown, Text, HTML)');
        console.log('  📥 Import from multiple formats');
        console.log('  ↶↷ Full undo/redo system');
        console.log('  ⌨️ Complete keyboard shortcuts');
        console.log('  📁 Project organization');
        console.log('  🔍 Search and filtering');
        console.log('  🗑️ Trash management');
        console.log('  🔔 Reminders and priorities');
        console.log('  💾 Auto-save with feedback');
        console.log('  🛡️ Enhanced error handling');
        console.log('🎯 Ready for manual testing!');
    </script>
</body>
</html>
